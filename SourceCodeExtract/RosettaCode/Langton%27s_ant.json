{"isSuccess":true,"url":"http://rosettacode.org/wiki/Langton%27s_ant","codeArray":[" // create global canvas\n var canvas = document.createElement('canvas');\n canvas.id = 'globalCanvas';\n document.body.appendChild(canvas);\n\n function langtonant(antx, optx) {\n     'use strict';\n     var x, y, i;\n     // extend default opts\n     var opts = {\n         gridsize: 100,\n         pixlsize: 4,\n         interval: 4\n     };\n     for (i in optx) {\n         opts[i] = optx[i];\n     }\n     // extend default ants\n     var ants = [{\n         x: 50,\n         y: 50,\n         d: 0\n     }];\n     for (i in antx) {\n         ants[i] = antx[i];\n     }\n     // initialise grid\n     var grid = [];\n     for (x = 0; x < opts.gridsize; x++) {\n         grid[x] = [];\n         for (y = 0; y < opts.gridsize; y++) {\n             grid[x][y] = true;\n         }\n     }\n     // initialise directions\n     var dirs = [{\n         x: 1,\n         y: 0\n     }, {\n         x: 0,\n         y: -1\n     }, {\n         x: -1,\n         y: 0\n     }, {\n         x: 0,\n         y: 1\n     }];\n     // initialise canvas\n     var canv = document.getElementById('globalCanvas');\n     var cont = canv.getContext('2d');\n     canv.width = opts.gridsize * opts.pixlsize;\n     canv.height = opts.gridsize * opts.pixlsize;\n     // initialise pixels\n     var pixlblac = cont.createImageData(opts.pixlsize, opts.pixlsize);\n     for (i = 0; i < (opts.pixlsize * opts.pixlsize * 4); i += 4) {\n         pixlblac.data[i + 3] = 255;\n     }\n     var pixlwhit = cont.createImageData(opts.pixlsize, opts.pixlsize);\n     for (i = 0; i < (opts.pixlsize * opts.pixlsize * 4); i += 4) {\n         pixlwhit.data[i + 3] = 0;\n     }\n     // run simulation\n     function simulate() {\n         var sane = true;\n         // iterate over ants\n         for (i = 0; i < ants.length; i++) {\n             var n = ants[i];\n             // invert, draw, turn\n             if (grid[n.x][n.y]) {\n                 grid[n.x][n.y] = false;\n                 cont.putImageData(pixlblac, n.x * opts.pixlsize, n.y * opts.pixlsize);\n                 n.d--;\n             } else {\n                 grid[n.x][n.y] = true;\n                 cont.putImageData(pixlwhit, n.x * opts.pixlsize, n.y * opts.pixlsize);\n                 n.d++;\n             }\n             // modulus wraparound\n             n.d += dirs.length;\n             n.d %= dirs.length;\n             // position + direction\n             n.x += dirs[n.d].x;\n             n.y += dirs[n.d].y;\n             // sanity check\n             sane = (n.x < 0 || n.x > opts.gridsize || n.y < 0 || n.y > opts.gridsize) ? false : sane;\n         }\n         // loop with interval\n         if (sane) {\n             setTimeout(simulate, opts.interval);\n         }\n     }\n     simulate();\n }"," langtonant({}, {\n     gridsize: 100,\n     pixlsize: 4,\n     interval: 4\n });"," langtonant([{\n     x: (100 / 2) + 7,\n     y: (100 / 2) + 7,\n     d: 1\n }, {\n     x: (100 / 2) + 7,\n     y: (100 / 2) - 7,\n     d: 2\n }, {\n     x: (100 / 2) - 7,\n     y: (100 / 2) - 7,\n     d: 3\n }, {\n     x: (100 / 2) - 7,\n     y: (100 / 2) + 7,\n     d: 0\n }]);"," ///////////////////\n // LODASH IMPORT //\n ///////////////////\n // import all lodash functions to the main namespace, but isNaN not to cause conflicts\n _.each(_.keys(_), k => window[k === 'isNaN' ? '_isNaN' : k] = _[k]);\n const\n     WORLD_WIDTH = 100,\n     WORLD_HEIGHT = 100,\n     PIXEL_SIZE = 4,\n     DIRTY_COLOR = '#000',\n     VIRGIN_COLOR = '#fff',\n     RUNS = 10000,\n     SPEED = 50,\n     //            up right down left\n     DIRECTIONS = [0, 1, 2, 3],\n     displayWorld = (world) => each(world, (row, rowidx) => {\n         each(row, (cell, cellidx) => {\n             canvas.fillStyle = cell === 1 ? DIRTY_COLOR : VIRGIN_COLOR;\n             canvas.fillRect(rowidx * PIXEL_SIZE, cellidx * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);\n         });\n     }),\n     moveAnt = (world, ant) => {\n         world[ant.x][ant.y] = world[ant.x][ant.y] === 1 ? 0 : 1;\n         ant.dir = DIRECTIONS[(4 + ant.dir + (world[ant.x][ant.y] === 0 ? 1 : -1)) % 4];\n         switch (ant.dir) {\n             case DIRECTIONS[0]:\n                 ant.y -= 1;\n                 break;\n             case DIRECTIONS[1]:\n                 ant.x -= 1;\n                 break;\n             case DIRECTIONS[2]:\n                 ant.y += 1;\n                 break;\n             case DIRECTIONS[3]:\n                 ant.x += 1;\n                 break;\n         }\n         return [world, ant];\n     },\n     updateWorld = (world, ant, runs) => {\n         [world, ant] = moveAnt(world, ant);\n         displayWorld(world);\n         if (runs > 0) setTimeout(partial(updateWorld, world, ant, --runs), SPEED);\n     },\n     canvas = document.getElementById('c').getContext('2d');\n let\n     world = map(range(WORLD_HEIGHT), i => map(range(WORLD_WIDTH), partial(identity, 0))),\n     ant = {\n         x: WORLD_WIDTH / 2,\n         y: WORLD_HEIGHT / 2,\n         dir: DIRECTIONS[0]\n     };\n canvas.canvas.width = WORLD_WIDTH * PIXEL_SIZE;\n canvas.canvas.height = WORLD_HEIGHT * PIXEL_SIZE;\n updateWorld(world, ant, RUNS);"],"uncertainCodeArray":[],"textArray":[]}