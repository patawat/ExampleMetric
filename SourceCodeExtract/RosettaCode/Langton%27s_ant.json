{"isSuccess":true,"url":"http://rosettacode.org/wiki/Langton%27s_ant","codeArray":[" // create global canvas\n  var canvas = document.createElement('canvas');\n  canvas.id = 'globalCanvas';\n  document.body.appendChild(canvas);\n  function langtonant(antx, optx) {\n  \t'use strict';\n  \tvar x, y, i;\n  \t// extend default opts\n  \tvar opts = {\n  \t\tgridsize: 100,\n  \t\tpixlsize: 4,\n  \t\tinterval: 4\n  \t};\n  \tfor (i in optx) {\n  \t\topts[i] = optx[i];\n  \t}\n  \t// extend default ants\n  \tvar ants = [{\n  \t\tx: 50,\n  \t\ty: 50,\n  \t\td: 0\n  \t}];\n  \tfor (i in antx) {\n  \t\tants[i] = antx[i];\n  \t}\n  \t// initialise grid\n  \tvar grid = [];\n  \tfor (x = 0; x < opts.gridsize; x ++) {\n  \t\tgrid[x] = [];\n  \t\tfor (y = 0; y < opts.gridsize; y ++) {\n  \t\t\tgrid[x][y] = true;\n  \t\t}\n  \t}\n  \t// initialise directions\n  \tvar dirs = [\n  \t\t{x: 1, y: 0},\n  \t\t{x: 0, y: -1},\n  \t\t{x: -1, y: 0},\n  \t\t{x: 0, y: 1}\n  \t];\n  \t// initialise canvas\n  \tvar canv = document.getElementById('globalCanvas');\n  \tvar cont = canv.getContext('2d');\n  \tcanv.width = opts.gridsize * opts.pixlsize;\n  \tcanv.height = opts.gridsize * opts.pixlsize;\n  \t// initialise pixels\n  \tvar pixlblac = cont.createImageData(opts.pixlsize, opts.pixlsize);\n  \tfor (i = 0; i < (opts.pixlsize * opts.pixlsize * 4); i += 4) {\n  \t\tpixlblac.data[i + 3] = 255;\n  \t}\n  \tvar pixlwhit = cont.createImageData(opts.pixlsize, opts.pixlsize);\n  \tfor (i = 0; i < (opts.pixlsize * opts.pixlsize * 4); i += 4) {\n  \t\tpixlwhit.data[i + 3] = 0;\n  \t}\n  \t// run simulation\n  \tfunction simulate() {\n  \t\tvar sane = true;\n  \t\t// iterate over ants\n  \t\tfor (i = 0; i < ants.length; i ++) {\n  \t\t\tvar n = ants[i];\n  \t\t\t// invert, draw, turn\n  \t\t\tif (grid[n.x][n.y]) {\n  \t\t\t\tgrid[n.x][n.y] = false;\n  \t\t\t\tcont.putImageData(pixlblac, n.x * opts.pixlsize, n.y * opts.pixlsize);\n  \t\t\t\tn.d --;\n  \t\t\t} else {\n  \t\t\t\tgrid[n.x][n.y] = true;\n  \t\t\t\tcont.putImageData(pixlwhit, n.x * opts.pixlsize, n.y * opts.pixlsize);\n  \t\t\t\tn.d ++;\n  \t\t\t}\n  \t\t\t// modulus wraparound\n  \t\t\tn.d += dirs.length;\n  \t\t\tn.d %= dirs.length;\n  \t\t\t// position + direction\n  \t\t\tn.x += dirs[n.d].x;\n  \t\t\tn.y += dirs[n.d].y;\n  \t\t\t// sanity check\n  \t\t\tsane = (n.x < 0 || n.x > opts.gridsize || n.y < 0 || n.y > opts.gridsize) ? false : sane;\n  \t\t}\n  \t\t// loop with interval\n  \t\tif (sane) {\n  \t\t\tsetTimeout(simulate, opts.interval);\n  \t\t}\n  \t}\n  \tsimulate();\n  }\n  langtonant({}, {\n  \tgridsize: 100,\n  \tpixlsize: 4,\n  \tinterval: 4\n  });\n  langtonant([\n  \t{\n  \t\tx: (100 / 2) + 7,\n  \t\ty: (100 / 2) + 7,\n  \t\td: 1\n  \t}, {\n  \t\tx: (100 / 2) + 7,\n  \t\ty: (100 / 2) - 7,\n  \t\td: 2\n  \t}, {\n  \t\tx: (100 / 2) - 7,\n  \t\ty: (100 / 2) - 7,\n  \t\td: 3\n  \t}, {\n  \t\tx: (100 / 2) - 7,\n  \t\ty: (100 / 2) + 7,\n  \t\td: 0\n  \t}\n  ]);\n  ///////////////////\n  // LODASH IMPORT //\n  ///////////////////\n  // import all lodash functions to the main namespace, but isNaN not to cause conflicts\n  _.each(_.keys(_), k => window[k === 'isNaN' ? '_isNaN' : k] = _[k]);\n  const\n  WORLD_WIDTH  = 100,\n  WORLD_HEIGHT = 100,\n  PIXEL_SIZE   = 4,\n  DIRTY_COLOR  = '#000',\n  VIRGIN_COLOR = '#fff',\n  RUNS         = 10000,\n  SPEED        = 50,\n  //            up right down left\n  DIRECTIONS = [0, 1,    2,    3],\n  displayWorld = (world) => each(world, (row, rowidx) => {\n    each(row, (cell, cellidx) => {\n      canvas.fillStyle = cell === 1 ? DIRTY_COLOR : VIRGIN_COLOR;\n      canvas.fillRect(rowidx * PIXEL_SIZE, cellidx * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);\n    });\n  }),\n  moveAnt = (world, ant) => {\n    world[ant.x][ant.y] = world[ant.x][ant.y] === 1 ? 0 : 1;\n    ant.dir             = DIRECTIONS[(4 + ant.dir + (world[ant.x][ant.y] === 0 ? 1 : -1)) % 4];\n    switch (ant.dir) {\n      case DIRECTIONS[0]:\n        ant.y -= 1;\n        break;\n      case DIRECTIONS[1]:\n        ant.x -= 1;\n        break;\n      case DIRECTIONS[2]:\n        ant.y += 1;\n        break;\n      case DIRECTIONS[3]:\n        ant.x += 1;\n        break;\n    }\n    return [world, ant];\n  },\n  updateWorld = (world, ant, runs) => {\n    [world, ant] = moveAnt(world, ant);\n    displayWorld(world);\n    if (runs > 0) setTimeout(partial(updateWorld, world, ant, --runs), SPEED);\n  },\n  canvas = document.getElementById('c').getContext('2d');\n  let\n  world = map(range(WORLD_HEIGHT), i => map(range(WORLD_WIDTH), partial(identity, 0))),\n  ant   = {\n    x:   WORLD_WIDTH  / 2,\n    y:   WORLD_HEIGHT / 2,\n    dir: DIRECTIONS[0]\n  };\n  canvas.canvas.width  = WORLD_WIDTH  * PIXEL_SIZE;\n  canvas.canvas.height = WORLD_HEIGHT * PIXEL_SIZE;\n  updateWorld(world, ant, RUNS);"],"uncertainCodeArray":[],"textArray":[]}