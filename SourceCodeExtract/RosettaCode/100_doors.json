{"isSuccess":true,"url":"http://rosettacode.org//wiki/100_doors","codeArray":[" var doors=[];\n  for(var i=0;i<100;i++)\n   doors[i]=false;             //create doors\n  for(var i=1;i<=100;i++)\n   for(var i2=i-1,g;i2<100;i2+=i)\n    doors[i2]=!doors[i2];      //toggle doors\n  for(var i=1;i<=100;i++)      //read doors\n   console.log(\"Door %d is %s\",i,doors[i-1]?\"open\":\"closed\")\n   (function () {\n    return chain(\n      // 100 passes ...\n      rng(0, 99).reduce(function (a, _, i) {\n        return a.slice(0, i).concat(\n          a.slice(i).map(function (v, j) {\n            return (i + j + 1) % (i + 1) ? v : {\n              door: v.door,\n              open: !v.open\n            };\n          })\n        )\n      }, \n      // 100 closed doors at start\n      Array.apply(null, Array(100)).map(function (x, i) {\n        return {\n          open: false,\n          door: i + 1\n        };\n      })),\n      // Filtering by chained function\n      function (door) {\n        return door.open ? [door] : [];\n      }\n    )\n    // Monadic bind (chain) for lists\n    function chain(xs, f) {\n      return [].concat.apply([], xs.map(f));\n    }\n    // range(1, 20) --> [1..20]\n    function rng(m, n) {\n      return Array.apply(null, Array(n - m + 1)).map(function (x, i) {\n        return m + i;\n      });\n    }\n  })();for (var door = 1; door <= 100; door++) {\n    var sqrt = Math.sqrt(door);\n    if (sqrt === (sqrt | 0)) {\n      console.log(\"Door %d is open\", door);\n    }\n  }for(var door=1;i<10/*Math.sqrt(100)*/;i++){\n   console.log(\"Door %d is open\",i*i);\n  }Array.apply(null, { length: 100 })\n    .map(function(v, i) { return i + 1; })\n      .forEach(function(door) { \n        var sqrt = Math.sqrt(door); \n        if (sqrt === (sqrt | 0)) {\n          console.log(\"Door %d is open\", door);\n        } \n      });(function () {\n    return chain(\n      rng(1, 100),\n      function (x) {\n        var root = Math.sqrt(x);\n        return root === Math.floor(root) ? inject(x) : fail();\n      }\n    );\n    /*************************************************************/\n    // monadic Bind/chain for lists\n    function chain(xs, f) {\n      return [].concat.apply([], xs.map(f));\n    }\n    // monadic Return/inject for lists\n    function inject(x) { return [x]; }\n    // monadic Fail for lists\n    function fail() { return []; }\n    // rng(1, 20) --> [1..20]\n    function rng(m, n) {\n      return Array.apply(null, Array(n - m + 1)).map(function (x, i) {\n        return m + i;\n      });\n    }\n  })();(function () {\n    return rng(1, 100).filter(\n      function (x) {\n        var root = Math.sqrt(x);\n        return root === Math.floor(root);\n      }\n    );\n    // rng(1, 20) --> [1..20]\n    function rng(m, n) {\n      return Array.apply(null, Array(n - m + 1)).map(function (x, i) {\n        return m + i;\n      });\n    }\n  })();(function () {\n    return rng(1, Math.sqrt(100)).map(function (x) {\n      return x * x;\n    });\n    // rng(1, 20) --> [1..20]\n    function rng(m, n) {\n      return Array.apply(null, Array(n - m + 1)).map(function (x, i) {\n        return m + i;\n      });\n    }\n  })(); \n  Array.apply(null, { length: 100 })\n    .map((v, i) => i + 1)\n      .forEach(door => { \n        var sqrt = Math.sqrt(door); \n        if (sqrt === (sqrt | 0)) {\n          console.log(\"Door %d is open\", door);\n        } \n      });// Array comprehension style\n  [ for (i of Array.apply(null, { length: 100 })) i ].forEach((_, i) => { \n    var door = i + 1\n    var sqrt = Math.sqrt(door); \n    if (sqrt === (sqrt | 0)) {\n      console.log(\"Door %d is open\", door);\n    } \n  });"],"uncertainCodeArray":[],"textArray":[]}