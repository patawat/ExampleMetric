{"isSuccess":true,"url":"http://rosettacode.org//wiki/Evolutionary_algorithm","codeArray":["// ------------------------------------- Cross-browser Compatibility -------------------------------------\n  /* Compatibility code to reduce an array\n   * Source: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Reduce\n   */\n  if (!Array.prototype.reduce) {\n      Array.prototype.reduce = function (fun /*, initialValue */ ) {\n          \"use strict\";\n          if (this === void 0 || this === null) throw new TypeError();\n          var t = Object(this);\n          var len = t.length >>> 0;\n          if (typeof fun !== \"function\") throw new TypeError();\n          // no value to return if no initial value and an empty array\n          if (len == 0 && arguments.length == 1) throw new TypeError();\n          var k = 0;\n          var accumulator;\n          if (arguments.length >= 2) {\n              accumulator = arguments[1];\n          } else {\n              do {\n                  if (k in t) {\n                      accumulator = t[k++];\n                      break;\n                  }\n                  // if array contains no values, no initial value to return\n                  if (++k >= len) throw new TypeError();\n              }\n              while (true);\n          }\n          while (k < len) {\n              if (k in t) accumulator = fun.call(undefined, accumulator, t[k], k, t);\n              k++;\n          }\n          return accumulator;\n      };\n  }\n  /* Compatibility code to map an array\n   * Source: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map\n   */\n  if (!Array.prototype.map) {\n      Array.prototype.map = function (fun /*, thisp */ ) {\n          \"use strict\";\n          if (this === void 0 || this === null) throw new TypeError();\n          var t = Object(this);\n          var len = t.length >>> 0;\n          if (typeof fun !== \"function\") throw new TypeError();\n          var res = new Array(len);\n          var thisp = arguments[1];\n          for (var i = 0; i < len; i++) {\n              if (i in t) res[i] = fun.call(thisp, t[i], i, t);\n          }\n          return res;\n      };\n  }\n  /* ------------------------------------- Generator -------------------------------------\n   * Generates a fixed length gene sequence via a gene strategy object.\n   * The gene strategy object must have two functions:\n   *\t- \"create\": returns create a new gene \n   *\t- \"mutate(existingGene)\": returns mutation of an existing gene  \n   */\n  function Generator(length, mutationRate, geneStrategy) {\n      this.size = length;\n      this.mutationRate = mutationRate;\n      this.geneStrategy = geneStrategy;\n  }\n  Generator.prototype.spawn = function () {\n      var genes = [],\n          x;\n      for (x = 0; x < this.size; x += 1) {\n          genes.push(this.geneStrategy.create());\n      }\n      return genes;\n  };\n  Generator.prototype.mutate = function (parent) {\n      return parent.map(function (char) {\n          if (Math.random() > this.mutationRate) {\n              return char;\n          }\n          return this.geneStrategy.mutate(char);\n      }, this);\n  };\n  /* ------------------------------------- Population -------------------------------------\n   * Helper class that holds and spawns a new population.\n   */\n  function Population(size, generator) {\n      this.size = size;\n      this.generator = generator;\n      this.population = [];\n      // Build initial popuation;\n      for (var x = 0; x < this.size; x += 1) {\n          this.population.push(this.generator.spawn());\n      }\n  }\n  Population.prototype.spawn = function (parent) {\n      this.population = [];\n      for (var x = 0; x < this.size; x += 1) {\n          this.population.push(this.generator.mutate(parent));\n      }\n  };\n  /* ------------------------------------- Evolver -------------------------------------\n   * Attempts to converge a population based a fitness strategy object.\n   * The fitness strategy object must have three function  \n   *\t- \"score(individual)\": returns a score for an individual.\n   *\t- \"compare(scoreA, scoreB)\": return true if scoreA is better (ie more fit) then scoreB\n   *\t- \"done( score )\": return true if score is acceptable (ie we have successfully converged). \n   */\n  function Evolver(size, generator, fitness) {\n      this.done = false;\n      this.fitness = fitness;\n      this.population = new Population(size, generator);\n  }\n  Evolver.prototype.getFittest = function () {\n      return this.population.population.reduce(function (best, individual) {\n          var currentScore = this.fitness.score(individual);\n          if (best === null || this.fitness.compare(currentScore, best.score)) {\n              return {\n                  score: currentScore,\n                  individual: individual\n              };\n          } else {\n              return best;\n          }\n      }, null);\n  };\n  Evolver.prototype.doGeneration = function () {\n      this.fittest = this.getFittest();\n      this.done = this.fitness.done(this.fittest.score);\n      if (!this.done) {\n          this.population.spawn(this.fittest.individual);\n      }\n  };\n  Evolver.prototype.run = function (onCheckpoint, checkPointFrequency) {\n      checkPointFrequency = checkPointFrequency || 10; // Default to Checkpoints every 10 generations\n      var generation = 0;\n      while (!this.done) {\n          this.doGeneration();\n          if (generation % checkPointFrequency === 0) {\n              onCheckpoint(generation, this.fittest);\n          }\n          generation += 1;\n      }\n      onCheckpoint(generation, this.fittest);\n      return this.fittest;\n  };\n  // ------------------------------------- Exports -------------------------------------\n  window.Generator = Generator;\n  window.Evolver = Evolver;\n  // helper utitlity to combine elements of two arrays.\n  Array.prototype.zip = function (b, func) {\n      var result = [],\n          max = Math.max(this.length, b.length),\n          x;\n      for (x = 0; x < max; x += 1) {\n          result.push(func(this[x], b[x]));\n      }\n      return result;\n  };\n  var target = \"METHINKS IT IS LIKE A WEASEL\", geneStrategy, fitness, target, generator, evolver, result;\n  geneStrategy = {\n      // The allowed character set (as an array) \n      characterSet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".split(\"\"),\n      /*\n          Pick a random character from the characterSet\n      */\n      create: function getRandomGene() {\n          var randomNumber = Math.floor(Math.random() * this.characterSet.length);\n          return this.characterSet[randomNumber];\n      }\n  };\n  geneStrategy.mutate = geneStrategy.create; // Our mutation stragtegy is to simply get a random gene\n  fitness = {\n      // The target (as an array of characters)\n      target: target.split(\"\"),\n      equal: function (geneA, geneB) {\n          return (geneA === geneB ? 0 : 1);\n      },\n      sum: function (runningTotal, value) {\n          return runningTotal + value;\n      },\n      /*\n          We give one point to for each corect letter\n      */\n      score: function (genes) {\n          var diff = genes.zip(this.target, this.equal); // create an array of ones and zeros \n          return diff.reduce(this.sum, 0); // Sum the array values together.\n      },\n      compare: function (scoreA, scoreB) {\n          return scoreA <= scoreB; // Lower scores are better\n      },\n      done: function (score) {\n          return score === 0; // We have matched the target string.\n      }\n  };\n  generator = new Generator(target.length, 0.05, geneStrategy);\n  evolver = new Evolver(100, generator, fitness);\n  function showProgress(generation, fittest) {\n      document.write(\"Generation: \" + generation + \", Best: \" + fittest.individual.join(\"\") + \", fitness:\" + fittest.score + \"<br>\");\n  }\n  result = evolver.run(showProgress);"],"uncertainCodeArray":[],"textArray":[]}