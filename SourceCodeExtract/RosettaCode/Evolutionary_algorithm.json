{"isSuccess":true,"url":"http://rosettacode.org//wiki/Evolutionary_algorithm","codeArray":["// ------------------------------------- Cross-browser Compatibility -------------------------------------\n/* Compatibility code to reduce an array\n * Source: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Reduce\n */\nif (!Array.prototype.reduce) {\n    Array.prototype.reduce = function(fun /*, initialValue */ ) {\n        \"use strict\";\n        if (this === void 0 || this === null) throw new TypeError();\n        var t = Object(this);\n        var len = t.length >>> 0;\n        if (typeof fun !== \"function\") throw new TypeError();\n        // no value to return if no initial value and an empty array\n        if (len == 0 && arguments.length == 1) throw new TypeError();\n        var k = 0;\n        var accumulator;\n        if (arguments.length >= 2) {\n            accumulator = arguments[1];\n        } else {\n            do {\n                if (k in t) {\n                    accumulator = t[k++];\n                    break;\n                }\n                // if array contains no values, no initial value to return\n                if (++k >= len) throw new TypeError();\n            }\n            while (true);\n        }\n        while (k < len) {\n            if (k in t) accumulator = fun.call(undefined, accumulator, t[k], k, t);\n            k++;\n        }\n        return accumulator;\n    };\n}\n/* Compatibility code to map an array\n * Source: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/Map\n */\nif (!Array.prototype.map) {\n    Array.prototype.map = function(fun /*, thisp */ ) {\n        \"use strict\";\n        if (this === void 0 || this === null) throw new TypeError();\n        var t = Object(this);\n        var len = t.length >>> 0;\n        if (typeof fun !== \"function\") throw new TypeError();\n        var res = new Array(len);\n        var thisp = arguments[1];\n        for (var i = 0; i < len; i++) {\n            if (i in t) res[i] = fun.call(thisp, t[i], i, t);\n        }\n        return res;\n    };\n}\n/* ------------------------------------- Generator -------------------------------------\n * Generates a fixed length gene sequence via a gene strategy object.\n * The gene strategy object must have two functions:\n *\t- \"create\": returns create a new gene \n *\t- \"mutate(existingGene)\": returns mutation of an existing gene  \n */\nfunction Generator(length, mutationRate, geneStrategy) {\n    this.size = length;\n    this.mutationRate = mutationRate;\n    this.geneStrategy = geneStrategy;\n}\nGenerator.prototype.spawn = function() {\n    var genes = [],\n        x;\n    for (x = 0; x < this.size; x += 1) {\n        genes.push(this.geneStrategy.create());\n    }\n    return genes;\n};\nGenerator.prototype.mutate = function(parent) {\n    return parent.map(function(char) {\n        if (Math.random() > this.mutationRate) {\n            return char;\n        }\n        return this.geneStrategy.mutate(char);\n    }, this);\n};\n/* ------------------------------------- Population -------------------------------------\n * Helper class that holds and spawns a new population.\n */\nfunction Population(size, generator) {\n    this.size = size;\n    this.generator = generator;\n    this.population = [];\n    // Build initial popuation;\n    for (var x = 0; x < this.size; x += 1) {\n        this.population.push(this.generator.spawn());\n    }\n}\nPopulation.prototype.spawn = function(parent) {\n    this.population = [];\n    for (var x = 0; x < this.size; x += 1) {\n        this.population.push(this.generator.mutate(parent));\n    }\n};\n/* ------------------------------------- Evolver -------------------------------------\n * Attempts to converge a population based a fitness strategy object.\n * The fitness strategy object must have three function  \n *\t- \"score(individual)\": returns a score for an individual.\n *\t- \"compare(scoreA, scoreB)\": return true if scoreA is better (ie more fit) then scoreB\n *\t- \"done( score )\": return true if score is acceptable (ie we have successfully converged). \n */\nfunction Evolver(size, generator, fitness) {\n    this.done = false;\n    this.fitness = fitness;\n    this.population = new Population(size, generator);\n}\nEvolver.prototype.getFittest = function() {\n    return this.population.population.reduce(function(best, individual) {\n        var currentScore = this.fitness.score(individual);\n        if (best === null || this.fitness.compare(currentScore, best.score)) {\n            return {\n                score: currentScore,\n                individual: individual\n            };\n        } else {\n            return best;\n        }\n    }, null);\n};\nEvolver.prototype.doGeneration = function() {\n    this.fittest = this.getFittest();\n    this.done = this.fitness.done(this.fittest.score);\n    if (!this.done) {\n        this.population.spawn(this.fittest.individual);\n    }\n};\nEvolver.prototype.run = function(onCheckpoint, checkPointFrequency) {\n    checkPointFrequency = checkPointFrequency || 10; // Default to Checkpoints every 10 generations\n    var generation = 0;\n    while (!this.done) {\n        this.doGeneration();\n        if (generation % checkPointFrequency === 0) {\n            onCheckpoint(generation, this.fittest);\n        }\n        generation += 1;\n    }\n    onCheckpoint(generation, this.fittest);\n    return this.fittest;\n};\n// ------------------------------------- Exports -------------------------------------\nwindow.Generator = Generator;\nwindow.Evolver = Evolver;\n// helper utitlity to combine elements of two arrays.\nArray.prototype.zip = function(b, func) {\n    var result = [],\n        max = Math.max(this.length, b.length),\n        x;\n    for (x = 0; x < max; x += 1) {\n        result.push(func(this[x], b[x]));\n    }\n    return result;\n};\nvar target = \"METHINKS IT IS LIKE A WEASEL\",\n    geneStrategy, fitness, target, generator, evolver, result;\ngeneStrategy = {\n    // The allowed character set (as an array) \n    characterSet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".split(\"\"),\n    /*\n        Pick a random character from the characterSet\n    */\n    create: function getRandomGene() {\n        var randomNumber = Math.floor(Math.random() * this.characterSet.length);\n        return this.characterSet[randomNumber];\n    }\n};\ngeneStrategy.mutate = geneStrategy.create; // Our mutation stragtegy is to simply get a random gene\nfitness = {\n    // The target (as an array of characters)\n    target: target.split(\"\"),\n    equal: function(geneA, geneB) {\n        return (geneA === geneB ? 0 : 1);\n    },\n    sum: function(runningTotal, value) {\n        return runningTotal + value;\n    },\n    /*\n        We give one point to for each corect letter\n    */\n    score: function(genes) {\n        var diff = genes.zip(this.target, this.equal); // create an array of ones and zeros \n        return diff.reduce(this.sum, 0); // Sum the array values together.\n    },\n    compare: function(scoreA, scoreB) {\n        return scoreA <= scoreB; // Lower scores are better\n    },\n    done: function(score) {\n        return score === 0; // We have matched the target string.\n    }\n};\ngenerator = new Generator(target.length, 0.05, geneStrategy);\nevolver = new Evolver(100, generator, fitness);\n\nfunction showProgress(generation, fittest) {\n    document.write(\"Generation: \" + generation + \", Best: \" + fittest.individual.join(\"\") + \", fitness:\" + fittest.score + \"<br>\");\n}\nresult = evolver.run(showProgress);"],"uncertainCodeArray":[],"textArray":[]}