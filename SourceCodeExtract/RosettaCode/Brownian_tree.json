{"isSuccess":true,"url":"http://rosettacode.org//wiki/Brownian_tree","codeArray":["function brownian(canvasId, messageId) {\n    var canvas = document.getElementById(canvasId);\n    var ctx = canvas.getContext(\"2d\");\n    // Options\n    var drawPos = true;\n    var seedResolution = 50;\n    var clearShade = 0; // 0..255\n    // Static state\n    var width = canvas.width;\n    var height = canvas.height;\n    var cx = width / 2;\n    var cy = height / 2;\n    var clearStyle = \"rgba(\" + clearShade + \", \" + clearShade + \", \" + clearShade + \", 1)\";\n    // Utilities\n    function radius(x, y) {\n        return Math.sqrt((x - cx) * (x - cy) + (y - cx) * (y - cy));\n    }\n\n    function test(x, y) {\n        if (x < 0 || y < 0 || x >= width || y >= height)\n            return false;\n        var data = ctx.getImageData(x, y, 1, 1).data;\n        return data[0] != clearShade || data[1] != clearShade || data[2] != clearShade;\n    }\n    var shade = 120;\n\n    function setc(x, y, c) {\n        //var imgd = ctx.createImageData(1, 1);\n        //var pix = imgd.data;\n        //pix[0] = pix[1] = pix[2] = c == 255 ? 255 : shade;\n        //pix[3] = 255;\n        //shade = (shade + 1) % 254;\n        //ctx.putImageData(imgd, x, y);\n        //ctx.fillStyle = \"rgba(\"+c+\", \"+c+\", \"+c+\", 1)\";\n        shade = (shade + 0.02) % 360;\n        if (c) {\n            ctx.fillStyle = \"hsl(\" + shade + \", 100%, 50%)\";\n        } else {\n            ctx.fillStyle = clearStyle;\n        }\n        ctx.fillRect(x, y, 1, 1);\n    }\n\n    function set(x, y) {\n        setc(x, y, true);\n    }\n\n    function clear(x, y) {\n        setc(x, y, false);\n    }\n    // Initialize canvas to blank opaque\n    ctx.fillStyle = clearStyle;\n    ctx.fillRect(0, 0, width, height);\n    // Current position\n    var x;\n    var y;\n    // Farthest distance from center a particle has yet been placed.\n    var closeRadius = 1;\n    // Place seed\n    set(cx, cy);\n    // Choose a new random position for a particle (not necessarily unoccupied)\n    function newpos() {\n        // Wherever particles are injected, the tree will tend to grow faster \n        // toward it. Ideally, particles wander in from infinity; the best we\n        // could do is to have them wander in from the edge of the field.\n        // But in order to have the rendering occur in a reasonable time when\n        // the seed is small, without too much visible bias, we instead place \n        // the particles in a coarse grid. The final tree will cover every\n        // point on the grid.\n        //\n        // There's probably a better strategy than this.\n        x = Math.floor(Math.random() * (width / seedResolution)) * seedResolution;\n        y = Math.floor(Math.random() * (height / seedResolution)) * seedResolution;\n    }\n    newpos();\n    var animation;\n    animation = window.setInterval(function() {\n        if (drawPos) clear(x, y);\n        for (var i = 0; i < 10000; i++) {\n            var ox = x;\n            var oy = y;\n            // Changing this to use only the first four directions will result\n            // in a denser tree.\n            switch (Math.floor(Math.random() * 8)) {\n                case 0:\n                    x++;\n                    break;\n                case 1:\n                    x--;\n                    break;\n                case 2:\n                    y++;\n                    break;\n                case 3:\n                    y--;\n                    break;\n                case 4:\n                    x++;\n                    y++;\n                    break;\n                case 5:\n                    x--;\n                    y++;\n                    break;\n                case 6:\n                    x++;\n                    y--;\n                    break;\n                case 7:\n                    x--;\n                    y--;\n                    break;\n            }\n            if (x < 0 || y < 0 ||\n                x >= width || y >= height ||\n                radius(x, y) > closeRadius + seedResolution + 2) {\n                // wandered out of bounds or out of interesting range of the\n                // tree, so pick a new spot\n                var progress = 1000;\n                do {\n                    newpos();\n                    progress--;\n                } while ((test(x - 1, y - 1) || test(x, y - 1) || test(x + 1, y - 1) ||\n                        test(x - 1, y) || test(x, y) || test(x + 1, y) ||\n                        test(x - 1, y + 1) || test(x, y + 1) || test(x + 1, y + 1)) && progress > 0);\n                if (progress <= 0) {\n                    document.getElementById(messageId).appendChild(\n                        document.createTextNode(\"Stopped for lack of room.\"));\n                    clearInterval(animation);\n                    break;\n                }\n            }\n            if (test(x, y)) {\n                // hit something, mark where we came from and pick a new spot\n                set(ox, oy);\n                closeRadius = Math.max(closeRadius, radius(ox, oy));\n                newpos();\n            }\n        }\n        if (drawPos) set(x, y);\n    }, 1);\n}"],"uncertainCodeArray":[],"textArray":[]}