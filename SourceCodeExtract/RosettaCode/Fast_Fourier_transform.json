{"isSuccess":true,"url":"http://rosettacode.org//wiki/Fast_Fourier_transform","codeArray":["/*\n  complex fast fourier transform and inverse from\n  http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B\n  */\nfunction icfft(amplitudes) {\n    var N = amplitudes.length;\n    var iN = 1 / N;\n    //conjugate if imaginary part is not 0\n    for (var i = 0; i < N; ++i)\n        if (amplitudes[i] instanceof Complex)\n            amplitudes[i].im = -amplitudes[i].im;\n        //apply fourier transform\n    amplitudes = cfft(amplitudes)\n    for (var i = 0; i < N; ++i) {\n        //conjugate again\n        amplitudes[i].im = -amplitudes[i].im;\n        //scale\n        amplitudes[i].re *= iN;\n        amplitudes[i].im *= iN;\n    }\n    return amplitudes;\n}\n\nfunction cfft(amplitudes) {\n    var N = amplitudes.length;\n    if (N <= 1)\n        return amplitudes;\n    var hN = N / 2;\n    var even = [];\n    var odd = [];\n    even.length = hN;\n    odd.length = hN;\n    for (var i = 0; i < hN; ++i) {\n        even[i] = amplitudes[i * 2];\n        odd[i] = amplitudes[i * 2 + 1];\n    }\n    even = cfft(even);\n    odd = cfft(odd);\n    var a = -2 * Math.PI;\n    for (var k = 0; k < hN; ++k) {\n        if (!(even[k] instanceof Complex))\n            even[k] = new Complex(even[k], 0);\n        if (!(odd[k] instanceof Complex))\n            odd[k] = new Complex(odd[k], 0);\n        var p = k / N;\n        var t = new Complex(0, a * p);\n        t.cexp(t).mul(odd[k], t);\n        amplitudes[k] = even[k].add(t, odd[k]);\n        amplitudes[k + hN] = even[k].sub(t, even[k]);\n    }\n    return amplitudes;\n}\n//test code\n//console.log( cfft([1,1,1,1,0,0,0,0]) );\n//console.log( icfft(cfft([1,1,1,1,0,0,0,0])) );","/*\n  basic complex number arithmetic from \n  http://rosettacode.org/wiki/Fast_Fourier_transform#Scala\n  */\nfunction Complex(re, im) {\n    this.re = re;\n    this.im = im || 0.0;\n}\nComplex.prototype.add = function(other, dst) {\n    dst.re = this.re + other.re;\n    dst.im = this.im + other.im;\n    return dst;\n}\nComplex.prototype.sub = function(other, dst) {\n    dst.re = this.re - other.re;\n    dst.im = this.im - other.im;\n    return dst;\n}\nComplex.prototype.mul = function(other, dst) {\n    //cache re in case dst === this\n    var r = this.re * other.re - this.im * other.im;\n    dst.im = this.re * other.im + this.im * other.re;\n    dst.re = r;\n    return dst;\n}\nComplex.prototype.cexp = function(dst) {\n    var er = Math.exp(this.re);\n    dst.re = er * Math.cos(this.im);\n    dst.im = er * Math.sin(this.im);\n    return dst;\n}\nComplex.prototype.log = function() {\n    /*\n    although 'It's just a matter of separating out the real and imaginary parts of jw.' is not a helpful quote\n    the actual formula I found here and the rest was just fiddling / testing and comparing with correct results.\n    http://cboard.cprogramming.com/c-programming/89116-how-implement-complex-exponential-functions-c.html#post637921\n    */\n    if (!this.re)\n        console.log(this.im.toString() + 'j');\n    else if (this.im < 0)\n        console.log(this.re.toString() + this.im.toString() + 'j');\n    else\n        console.log(this.re.toString() + '+' + this.im.toString() + 'j');\n}"],"uncertainCodeArray":[],"textArray":[]}