{"isSuccess":true,"url":"http://rosettacode.org//wiki/Fast_Fourier_transform","codeArray":["/*\n  complex fast fourier transform and inverse from\n  http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B\n  */\n  function icfft(amplitudes)\n  {\n  \tvar N = amplitudes.length;\n  \tvar iN = 1 / N;\n  \t//conjugate if imaginary part is not 0\n  \tfor(var i = 0 ; i < N; ++i)\n  \t\tif(amplitudes[i] instanceof Complex)\n  \t\t\tamplitudes[i].im = -amplitudes[i].im;\n  \t//apply fourier transform\n  \tamplitudes = cfft(amplitudes)\n  \tfor(var i = 0 ; i < N; ++i)\n  \t{\n  \t\t//conjugate again\n  \t\tamplitudes[i].im = -amplitudes[i].im;\n  \t\t//scale\n  \t\tamplitudes[i].re *= iN;\n  \t\tamplitudes[i].im *= iN;\n  \t}\n  \treturn amplitudes;\n  }\n  function cfft(amplitudes)\n  {\n  \tvar N = amplitudes.length;\n  \tif( N <= 1 )\n  \t\treturn amplitudes;\n  \tvar hN = N / 2;\n  \tvar even = [];\n  \tvar odd = [];\n  \teven.length = hN;\n  \todd.length = hN;\n  \tfor(var i = 0; i < hN; ++i)\n  \t{\n  \t\teven[i] = amplitudes[i*2];\n  \t\todd[i] = amplitudes[i*2+1];\n  \t}\n  \teven = cfft(even);\n  \todd = cfft(odd);\n  \tvar a = -2*Math.PI;\n  \tfor(var k = 0; k < hN; ++k)\n  \t{\n  \t\tif(!(even[k] instanceof Complex))\n  \t\t\teven[k] = new Complex(even[k], 0);\n  \t\tif(!(odd[k] instanceof Complex))\n  \t\t\todd[k] = new Complex(odd[k], 0);\n  \t\tvar p = k/N;\n  \t\tvar t = new Complex(0, a * p);\n  \t\tt.cexp(t).mul(odd[k], t);\n  \t\tamplitudes[k] = even[k].add(t, odd[k]);\n  \t\tamplitudes[k + hN] = even[k].sub(t, even[k]);\n  \t}\n  \treturn amplitudes;\n  }\n  //test code\n  //console.log( cfft([1,1,1,1,0,0,0,0]) );\n  //console.log( icfft(cfft([1,1,1,1,0,0,0,0])) );/*\n  basic complex number arithmetic from \n  http://rosettacode.org/wiki/Fast_Fourier_transform#Scala\n  */\n  function Complex(re, im) \n  {\n  \tthis.re = re;\n  \tthis.im = im || 0.0;\n  }\n  Complex.prototype.add = function(other, dst)\n  {\n  \tdst.re = this.re + other.re;\n  \tdst.im = this.im + other.im;\n  \treturn dst;\n  }\n  Complex.prototype.sub = function(other, dst)\n  {\n  \tdst.re = this.re - other.re;\n  \tdst.im = this.im - other.im;\n  \treturn dst;\n  }\n  Complex.prototype.mul = function(other, dst)\n  {\n  \t//cache re in case dst === this\n  \tvar r = this.re * other.re - this.im * other.im;\n  \tdst.im = this.re * other.im + this.im * other.re;\n  \tdst.re = r;\n  \treturn dst;\n  }\n  Complex.prototype.cexp = function(dst)\n  {\n  \tvar er = Math.exp(this.re);\n  \tdst.re = er * Math.cos(this.im);\n  \tdst.im = er * Math.sin(this.im);\n  \treturn dst;\n  }\n  Complex.prototype.log = function()\n  {\n  \t/*\n  \talthough 'It's just a matter of separating out the real and imaginary parts of jw.' is not a helpful quote\n  \tthe actual formula I found here and the rest was just fiddling / testing and comparing with correct results.\n  \thttp://cboard.cprogramming.com/c-programming/89116-how-implement-complex-exponential-functions-c.html#post637921\n  \t*/\n  \tif( !this.re )\n  \t\tconsole.log(this.im.toString()+'j');\n  \telse if( this.im < 0 )\n  \t\tconsole.log(this.re.toString()+this.im.toString()+'j');\n  \telse\n  \t\tconsole.log(this.re.toString()+'+'+this.im.toString()+'j');\n  }"],"uncertainCodeArray":[],"textArray":[]}