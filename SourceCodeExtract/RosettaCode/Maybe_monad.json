{"isSuccess":true,"url":"http://rosettacode.org//wiki/Monads/Maybe_monad","codeArray":["(function () {\n      'use strict';\n      // START WITH SOME SIMPLE (UNSAFE) PARTIAL FUNCTIONS:\n      // Returns Infinity if n === 0\n      function reciprocal(n) {\n          return 1 / n;\n      }\n      // Returns NaN if n < 0\n      function root(n) {\n          return Math.sqrt(n);\n      }\n      // Returns -Infinity if n === 0\n      // Returns NaN if n < 0\n      function log(n) {\n          return Math.log(n);\n      }\n      // NOW DERIVE SAFE VERSIONS OF THESE SIMPLE FUNCTIONS:\n      // These versions use a validity test, and return a wrapped value\n      // with a boolean .isValid property as well as a .value property\n      function safeVersion(f, fnSafetyCheck) {\n          return function (v) {\n              return maybe(fnSafetyCheck(v) ? f(v) : undefined);\n          }\n      }\n      var safe_reciprocal = safeVersion(reciprocal, function (n) {\n          return n !== 0;\n      });\n      var safe_root = safeVersion(root, function (n) {\n          return n >= 0;\n      });\n      var safe_log = safeVersion(log, function (n) {\n          return n > 0;\n      });\n      // THE DERIVATION OF THE SAFE VERSIONS USED THE 'UNIT' OR 'RETURN' \n      // FUNCTION OF THE MAYBE MONAD\n      // Named maybe() here, the unit function of the Maybe monad wraps a raw value \n      // in a datatype with two elements: .isValid (Bool) and .value (Number)\n      // a -> Ma\n      function maybe(n) {\n          return {\n              isValid: (typeof n !== 'undefined'),\n              value: n\n          };\n      }\n      // THE PROBLEM FOR FUNCTION NESTING (COMPOSITION) OF THE SAFE FUNCTIONS\n      // IS THAT THEIR INPUT AND OUTPUT TYPES ARE DIFFERENT\n      // Our safe versions of the functions take simple numeric arguments, but return\n      // wrapped results. If we feed a wrapped result as an input to another safe function,\n      // it will choke on the unexpected type. The solution is to write a higher order\n      // function (sometimes called 'bind' or 'chain') which handles composition, taking a \n      // a safe function and a wrapped value as arguments,\n      // The 'bind' function of the Maybe monad:\n      // 1. Applies a 'safe' function directly to the raw unwrapped value, and\n      // 2. returns the wrapped result.\n      // Ma -> (a -> Mb) -> Mb\n      function bind(maybeN, mf) {\n          return (maybeN.isValid ? mf(maybeN.value) : maybeN);\n      }\n      // Using the bind function, we can nest applications of safe_ functions,\n      // without their choking on unexpectedly wrapped values returned from\n      // other functions of the same kind.\n      var rootOneOverFour = bind(\n          bind(maybe(4), safe_reciprocal), safe_root\n      ).value;\n      // -> 0.5\n      // We can compose a chain of safe functions (of any length) with a simple foldr/reduceRight\n      // which starts by 'lifting' the numeric argument into a Maybe wrapping,\n      // and then nests function applications (working from right to left)\n      function safeCompose(lstFunctions, value) {\n          return lstFunctions\n              .reduceRight(function (a, f) {\n                  return bind(a, f);\n              }, maybe(value));\n      }\n      // TEST INPUT VALUES WITH A SAFELY COMPOSED VERSION OF LOG(SQRT(1/X))\n      var safe_log_root_reciprocal = function (n) {\n          return safeCompose([safe_log, safe_root, safe_reciprocal], n).value;\n      }\n      return [-2, -1, -0.5, 0, 1 / Math.E, 1, 2, Math.E, 3, 4, 5].map(\n          safe_log_root_reciprocal\n      );\n  })();"],"uncertainCodeArray":[],"textArray":[]}