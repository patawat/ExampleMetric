{"isSuccess":true,"url":"http://rosettacode.org//wiki/Y_combinator","codeArray":["function Y(f) {\n    var g = f((function(h) {\n        return function() {\n            var g = f(h(h));\n            return g.apply(this, arguments);\n        }\n    })(function(h) {\n        return function() {\n            var g = f(h(h));\n            return g.apply(this, arguments);\n        }\n    }));\n    return g;\n}\nvar fac = Y(function(f) {\n    return function(n) {\n        return n > 1 ? n * f(n - 1) : 1;\n    };\n});\nvar fib = Y(function(f) {\n    return function(n) {\n        return n > 1 ? f(n - 1) + f(n - 2) : n;\n    };\n});","function Y(f) {\n    return (function(h) {\n        return h(h);\n    })(function(h) {\n        return f(function() {\n            return h(h).apply(this, arguments);\n        });\n    });\n}","function pseudoY(f) {\n    return (function(h) {\n        return h(h);\n    })(function(h) {\n        return f.bind(function() {\n            return h(h).apply(null, arguments);\n        });\n    });\n}\nvar fac = pseudoY(function(n) {\n    return n > 1 ? n * this(n - 1) : 1;\n});\nvar fib = pseudoY(function(n) {\n    return n > 1 ? this(n - 1) + this(n - 2) : n;\n});","function Y(f) {\n    return function() {\n        return f(Y(f)).apply(this, arguments);\n    };\n}","function Y(f) {\n    return function() {\n        return f(arguments.callee).apply(this, arguments);\n    };\n}","let\n    Y = // Except for the η-abstraction necessary for applicative order languages, this is the formal Y combinator.\n    f => ((g => (f((...x) => g(g)(...x))))\n        (g => (f((...x) => g(g)(...x))))),\n    Y2 = // Using β-abstraction to eliminate code repetition.\n    f => ((f => f(f))\n        (g => (f((...x) => g(g)(...x))))),\n    Y3 = // Using β-abstraction to separate out the self application combinator δ.\n    ((δ => f => δ(g => (f((...x) => g(g)(...x)))))\n        ((f => f(f)))),\n    fix = // β/η-equivalent fix point combinator. Easier to convert to memoise than the Y combinator.\n    (((f) => (g) => (h) => (f(h)(g(h)))) // The Substitute combinator out of SKI calculus\n        ((f) => (g) => (...x) => (f(g(g)))(...x)) // S((S(KS)K)S(S(KS)K))(KI)\n        ((f) => (g) => (...x) => (f(g(g)))(...x))),\n    fix2 = // β/η-converted form of fix above into a more compact form\n    f => (f => f(f))(g => (...x) => f(g(g))(...x)),\n    opentailfact = // Open version of the tail call variant of the factorial function\n    fact => (n, m = 1) => n < 2 ? m : fact(n - 1, n * m);\ntailfact = // Tail call version of factorial function\n    Y(parttailfact);","let\n    polyfix = // A version that takes an array instead of multiple arguments would simply use l instead of (...l) for parameter\n    (...l) => (\n        (f => f(f))\n        (g => l.map(f => (...x) => f(...g(g))(...x)))),\n    [even, odd] = // The new destructive assignment syntax for arrays\n    polyfix(\n        (even, odd) => n => (n === 0) || odd(n - 1),\n        (even, odd) => n => (n !== 0) && even(n - 1));"],"uncertainCodeArray":[],"textArray":[]}