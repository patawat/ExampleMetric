{"isSuccess":true,"url":"http://rosettacode.org//wiki/Monads/List_monad","codeArray":[" Array.prototype.bind = function(func) {\n     return this.map(func).reduce(function(acc, a) {\n         return acc.concat(a);\n     });\n }\n Array.unit = function(elem) {\n     return [elem];\n }\n Array.lift = function(func) {\n     return function(elem) {\n         return Array.unit(func(elem));\n     };\n }\n inc = function(n) {\n     return n + 1;\n }\n doub = function(n) {\n     return 2 * n;\n }\n listy_inc = Array.lift(inc);\n listy_doub = Array.lift(doub);\n [3, 4, 5].bind(listy_inc).bind(listy_doub); // [8, 10, 12]","(function(n) {\n    // ENCODING A SET COMPREHENSION IN TERMS OF A LIST MONAD\n    // Pythagorean triples drawn from integers in the range [1..25]\n    // Each range of integers here represents the set of possible values for the variable.\n    // Where the test returns true for a particular [x, y, z] triple, we return that triple\n    // to the expected data type, wrapping it using the unit or return function;\n    // Where the test returns false, we return the empty list, which vanishes from the \n    // results set under concatenation, giving us a convenient encoding of filtering.\n    // {(x, y, z) | x <- [1..n], y <- [x+1..n], z <- [y+1..n], (x^2 + y^2 = z^2)} \n    return bind(rng(1, n), function(x) {\n        return bind(rng(1 + x, n), function(y) {\n            return bind(rng(1 + y, n), function(z) {\n                return (x * x + y * y === z * z) ? unit([x, y, z]) : [];\n            })\n        })\n    });\n    // Monadic return/unit/inject for lists just wraps a value in a list\n    // a -> [a]\n    function unit(a) {\n        return [a];\n    }\n    // Bind for lists is simply ConcatMap\n    // which applies a function f directly to each value in the list,\n    // and returns the set of results as a concat-flattened list\n    // [a] -> (a -> [b]) -> [b]\n    function bind(xs, f) {\n        return [].concat.apply([], xs.map(f));\n    }\n    // we will need some ranges of integers, each expressing a range of possible values\n    // [m..n]\n    function rng(m, n) {\n        return Array.apply(null, Array(n - m + 1))\n            .map(function(x, i) {\n                return m + i;\n            });\n    }\n})(25);"],"uncertainCodeArray":[],"textArray":[]}