{"isSuccess":true,"url":"http://rosettacode.org//wiki/List_comprehensions","codeArray":["function range(begin, end) {\n    for (let i = begin; i < end; ++i)\n        yield i;\n}\n\nfunction triples(n) {\n    return [\n        [x, y, z]\n        for each(x in range(1, n + 1))\n        for each(y in range(x, n + 1))\n        for each(z in range(y, n + 1))\n        if (x * x + y * y == z * z)\n    ]\n}\nfor each(var triple in triples(20))\nprint(triple);","// USING A LIST MONAD DIRECTLY, WITHOUT SPECIAL SYNTAX FOR LIST COMPREHENSIONS\n(function(n) {\n    return mb(r(1, n), function(x) { // x <- [1..n]\n        return mb(r(1 + x, n), function(y) { // y <- [1+x..n]\n            return mb(r(1 + y, n), function(z) { // z <- [1+y..n]\n                return x * x + y * y === z * z ? [\n                    [x, y, z]\n                ] : [];\n            })\n        })\n    });\n    // LIBRARY FUNCTIONS\n    // Monadic bind for lists\n    function mb(xs, f) {\n        return [].concat.apply([], xs.map(f));\n    }\n    // Monadic return for lists is simply lambda x -> [x]\n    // as in [[x, y, z]]Â : [] above\n    // Integer range [m..n]\n    function r(m, n) {\n        return Array.apply(null, Array(n - m + 1))\n            .map(function(n, x) {\n                return m + x;\n            });\n    }\n})(100);"],"uncertainCodeArray":[],"textArray":[]}