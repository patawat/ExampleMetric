{"isSuccess":true,"url":"http://rosettacode.org//wiki/Base64_encode_data","codeArray":["(function(){//ECMAScript doesn't have an internal base64 function or method, so we have to do it ourselves, isn't that exciting?\n      function stringToArrayUnicode(str){for(var i=0,l=str.length,n=[];i<l;i++)n.push(str.charCodeAt(i));return n;}\n      function generateOnesByLength(n){//Attempts to generate a binary number full of ones given a length.. they don't redefine each other that much.\n          var x=0;\n          for(var i=0;i<n;i++){\n              x<<=1;x|=1;//I don't know if this is performant faster than Math.pow but seriously I don't think I'll need Math.pow, do I?\n          }\n          return x;\n      }\n      function paf(_offset,_offsetlength,_number){//I don't have any name for this function at ALL, but I will explain what it does, it takes an offset, a number and returns the base64 number and the offset of the next number.\n          //the next function will be used to extract the offset of the number..\n          var a=6-_offsetlength,b=8-a;//Oh god, 8 is HARDCODED! Because 8 is the number of bits in a byte!!!\n          //And 6 is the mini-byte used by wikipedia base64 article... at least on 2013.\n          //I imagine this code being read in 2432 or something, that probably won't happen..\n          return [_number&generateOnesByLength(b),b,(_offset<<a)|(_number>>b)];//offset & offsetlength & number \n      }\n      function toBase64(uint8array){//of bits, each value may not have more than 255 bits... //a normal \"array\" should work fine too..\n          //From 0x29 to 0x5a plus from 0x61 to 0x7A AND from 0x30 to 0x39\n          //Will not report errors if an array index has a value bigger than 255.. it will likely fail.\n          var a=[],i,output=[];\n          for(i=0x41;i<=0x5a;i++){//A-Z\n              a.push(String.fromCharCode(i));\n          }\n          for(i=0x61;i<=0x7A;i++){//a-z\n              a.push(String.fromCharCode(i));\n          }\n          for(i=0x30;i<=0x39;i++){//0-9\n              a.push(String.fromCharCode(i));\n          }\n          a.push('+','/');\n          var offset=0,offsetLength=0,x;\n          for(var i=0,l=uint8array.length;i<l;i++){\n              if(offsetLength==6){//if offsetlength is 6 that means that a whole offset is occupying the space of a byte, can you believe it.\n                  offsetLength=0;\n                  output.push(a[offset]);\n                  offset=0;\n                  i--;\n                  continue;\n              }\n              x=paf(offset,offsetLength,uint8array[i]);\n              offset=x[0];\n              offsetLength=x[1];\n              output.push(a[x[2]]);\n          }\n          if(offsetLength){\n              if(offsetLength==6){\n                  output.push(a[offset]);\n              }else{\n                  var y=(6-offsetLength)/2;\n                  x=paf(offset,offsetLength,0);\n                  offset=x[0];\n                  output.push(a[x[2]]);\n                  switch (y){\n                      case 2:output.push('=');//This thingy right here, you know.. the offsets also, no break statement;\n                      case 1:output.push('=');break;\n                  }\n              }\n          }\n          return output.join('');//You can change it so the result is an array instead!!!!\n      }\n      //Usage\n      return toBase64(stringToArrayUnicode(\"Nothing seems hard to the people who don't know what they're talking about.\"))\n  }())window.btoa(\"String to encode, etc..\");//Will throw error if any unicode character is larger than 255 it's counterpart it's the window.atobvar http = require('http');\n  var options = {\n    host: 'rosettacode.org',\n    path: '/favicon.ico'\n  };\n  callback = function(response) {\n    var str = '';\n    response.on('data', function (chunk) {\n      str += chunk;\n    });\n    response.on('end', function () {\n      console.log(new Buffer(str).toString('base64'));//Base64 encoding right here.\n    });\n  }"],"uncertainCodeArray":[],"textArray":[]}