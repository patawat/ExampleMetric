{"isSuccess":true,"url":"http://rosettacode.org//wiki/Dragon_curve","codeArray":["var DRAGON = (function () {\n     // MATRIX MATH\n     // -----------\n     var matrix = {\n        mult: function ( m, v ) {\n           return [ m[0][0] * v[0] + m[0][1] * v[1],\n                    m[1][0] * v[0] + m[1][1] * v[1] ];\n        },\n        minus: function ( a, b ) {\n           return [ a[0]-b[0], a[1]-b[1] ];\n        },\n        plus: function ( a, b ) {\n           return [ a[0]+b[0], a[1]+b[1] ];\n        }\n     };\n     // SVG STUFF\n     // ---------\n     // Turn a pair of points into an SVG path like \"M1 1L2 2\".\n     var toSVGpath = function (a, b) {  // type system fail\n        return \"M\" + a[0] + \" \" + a[1] + \"L\" + b[0] + \" \" + b[1];\n     };\n     // DRAGON MAKING\n     // -------------\n     // Make a dragon with a better fractal algorithm\n     var fractalMakeDragon = function (svgid, ptA, ptC, state, lr, interval) {\n        // make a new <path>\n        var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n        path.setAttribute( \"class\",  \"dragon\"); \n        path.setAttribute( \"d\", toSVGpath(ptA, ptC) );\n        // append the new path to the existing <svg>\n        var svg = document.getElementById(svgid); // call could be eliminated\n        svg.appendChild(path);\n        // if we have more iterations to go...\n        if (state > 1) {\n           // make a new point, either to the left or right\n           var growNewPoint = function (ptA, ptC, lr) {\n              var left  = [[ 1/2,-1/2 ], \n                           [ 1/2, 1/2 ]]; \n              var right = [[ 1/2, 1/2 ],\n                           [-1/2, 1/2 ]];\n              return matrix.plus(ptA, matrix.mult( lr ? left : right, \n                                                   matrix.minus(ptC, ptA) ));\n           }; \n           var ptB = growNewPoint(ptA, ptC, lr, state);\n           // then recurse using each new line, one left, one right\n           var recurse = function () {\n              // when recursing deeper, delete this svg path\n              svg.removeChild(path);\n              // then invoke again for new pair, decrementing the state\n              fractalMakeDragon(svgid, ptB, ptA, state-1, lr, interval);\n              fractalMakeDragon(svgid, ptB, ptC, state-1, lr, interval);\n           };\n           window.setTimeout(recurse, interval);\n        }\n     };\n     // Export these functions\n     // ----------------------\n     return {\n        fractal: fractalMakeDragon\n        // ARGUMENTS\n        // ---------\n        //    svgid    id of <svg> element\n        //    ptA      first point [x,y] (from top left)\n        //    ptC      second point [x,y]\n        //    state    number indicating how many steps to recurse\n        //    lr       true/false to make new point on left or right\n        // CONFIG\n        // ------\n        // CSS rules should be made for the following\n        //    svg#fractal\n        //    svg path.dragon\n     };\n  }());"],"uncertainCodeArray":[],"textArray":[]}