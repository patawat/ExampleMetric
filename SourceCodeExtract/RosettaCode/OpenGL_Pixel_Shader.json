{"isSuccess":true,"url":"http://rosettacode.org//wiki/OpenGL_Pixel_Shader","codeArray":["< html style = \"margin: 0;\" >\n    <\n    head >\n    <\n    title > Fragment Shader WebGL Example < /title>\n    <!-- This use of <script> elements is so that we can have multiline text\nwithout quoting it inside of JavaScript;\nthe web browser doesn 't\nactually do anything besides store the text of these. -->\n    <\n    script id = \"shader-fs\"\ntype = \"text/x-fragment_shader\" >\n    precision highp float;\nuniform float u_time;\nvoid main(void) {\n        // some gobbledegook\n        vec3 foo = vec3(pow(gl_FragCoord.xy, vec2(1.0 + sin(dot(vec4(1.0, 100.0, 0.0, 0.0), gl_FragCoord)))), 0.0);\n        foo *= mat3(1.2, 3.9, 1.4, 4.1, 0.2, 1.4, 2.5, 1.6, 7.2);\n        gl_FragColor = vec4(mod(foo + vec3(u_time), 1.0), 1.0);\n    } <\n    /script> <\n    script id = \"shader-vs\"\ntype = \"text/x-vertex_shader\" >\n    attribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvoid main(void) {\n        gl_Position = vec4(a_position, 1.0);\n        v_color = a_color;\n    } <\n    /script> <\n    script type = \"text/javascript\" >\n    function getShader(gl, id) {\n        var scriptElement = document.getElementById(id);\n        // Create shader object\n        var shader;\n        shader = gl.createShader(gl[scriptElement.type.replace('text/x-', '').toUpperCase()]);\n        // Compile shader from source\n        gl.shaderSource(shader, scriptElement.textContent);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            throw new Error(gl.getShaderInfoLog(shader));\n        return shader;\n    } <\n    /script> <\n    /head> <\n    body style = \"margin: 0;\" >\n    <\n    canvas id = \"glcanvas\"\nstyle = \"border: none; margin: auto; display: block;\"\nwidth = \"640\"\nheight = \"480\" > < /canvas> <\n    script type = \"text/javascript\" >\n    var canvas = document.getElementById(\"glcanvas\");\n// Get WebGL context.\nvar gl = canvas.getContext(\"webgl\") ||\n    canvas.getContext(\"experimental-webgl\");\nif (!gl)\n    throw new Error(\"WebGL context not found\");\n// Create shader program from vertex and fragment shader code.\nvar shaderProgram = gl.createProgram();\ngl.attachShader(shaderProgram, getShader(gl, \"shader-vs\"));\ngl.attachShader(shaderProgram, getShader(gl, \"shader-fs\"));\ngl.linkProgram(shaderProgram);\nif (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))\n    throw new Error(gl.getProgramInfoLog(shaderProgram));\n// Specify to render using that program.\ngl.useProgram(shaderProgram);\n// Get the indexes to communicate vertex attributes to the program.\nvar positionAttr = gl.getAttribLocation(shaderProgram, \"a_position\");\n// And specify that we will be actually delivering data to those attributes.\ngl.enableVertexAttribArray(positionAttr);\nvar timeUniform = gl.getUniformLocation(shaderProgram, \"u_time\");\n// Store vertex positions and colors in array buffer objects.\nvar vertices;\nvar positionBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices = [-0.5, -0.5, 0, +0.5, -0.5, 0, -0.5, +0.5, 0]), gl.STATIC_DRAW);\nvar numVertices = vertices.length / 3; // 3 coordinates per vertex\n// Set GL state\ngl.clearColor(0.3, 0.3, 0.3, 1.0);\ngl.enable(gl.DEPTH_TEST);\ngl.viewport(0, 0, gl.drawingBufferWidth || canvas.width,\n    gl.drawingBufferHeight || canvas.height);\n//Specify the array data to render. \ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\ngl.vertexAttribPointer(positionAttr, 3, gl.FLOAT, false, 0, 0);\nvar t0 = Date.now();\n\nfunction frame() {\n    gl.uniform1f(timeUniform, (Date.now() - t0) / 1000);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.drawArrays(gl.TRIANGLES, 0, numVertices);\n    var e;\n    while (e = gl.getError())\n        console.log(\"GL error\", e);\n}\nsetInterval(frame, 1000 / 20); <\n/script> <\n/body> <\n/html>"],"uncertainCodeArray":[],"textArray":[]}