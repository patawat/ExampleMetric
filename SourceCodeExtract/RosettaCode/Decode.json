{"isSuccess":true,"url":"http://rosettacode.org//wiki/Roman_numerals/Decode","codeArray":["var Roman = {\n    Values: [\n        ['M', 1000],\n        ['CM', 900],\n        ['D', 500],\n        ['CD', 400],\n        ['C', 100],\n        ['XC', 90],\n        ['L', 50],\n        ['XL', 40],\n        ['X', 10],\n        ['IX', 9],\n        ['V', 5],\n        ['IV', 4],\n        ['I', 1]\n    ],\n    parse: function(str) {\n        var result = 0\n        for (var i = 0; i < Roman.Values.length; ++i) {\n            var pair = Roman.Values[i]\n            var key = pair[0]\n            var value = pair[1]\n            var regex = RegExp('^' + key)\n            while (str.match(regex)) {\n                result += value\n                str = str.replace(regex, '')\n            }\n        }\n        return result\n    }\n}\nvar test_data = ['MCMXC', 'MDCLXVI', 'MMVIII']\nfor (var i = 0; i < test_data.length; ++i) {\n    var test_datum = test_data[i]\n    print(test_datum + \": \" + Roman.parse(test_datum))\n}","(function(lstTest) {\n    var mapping = [\n        [\"M\", 1000],\n        [\"CM\", 900],\n        [\"D\", 500],\n        [\"CD\", 400],\n        [\"C\", 100],\n        [\n            \"XC\", 90\n        ],\n        [\"L\", 50],\n        [\"XL\", 40],\n        [\"X\", 10],\n        [\"IX\", 9],\n        [\"V\", 5],\n        [\"IV\",\n            4\n        ],\n        [\"I\", 1]\n    ];\n    // s -> n\n    function romanValue(s) {\n        // recursion over list of characters\n        // [c] -> n\n        function toArabic(lst) {\n            return lst.length ? function(xs) {\n                var lstParse = chain(mapping, function(lstPair) {\n                    return isPrefixOf(\n                        lstPair[0], xs\n                    ) ? [lstPair[1], drop(lstPair[0].length, xs)] : []\n                });\n                return lstParse[0] + toArabic(lstParse[1]);\n            }(lst) : 0\n        }\n        return toArabic(s.split(''));\n    }\n    // Monadic bind (chain) for lists\n    function chain(xs, f) {\n        return [].concat.apply([], xs.map(f));\n    }\n    // [a] -> [a] -> Bool\n    function isPrefixOf(lstFirst, lstSecond) {\n        return lstFirst.length ? (\n            lstSecond.length ?\n            lstFirst[0] === lstSecond[0] && isPrefixOf(\n                lstFirst.slice(1), lstSecond.slice(1)\n            ) : false\n        ) : true;\n    }\n    // Int -> [a] -> [a]\n    function drop(n, lst) {\n        return n <= 0 ? lst : (\n            lst.length ? drop(n - 1, lst.slice(1)) : []\n        );\n    }\n    return lstTest.map(romanValue);\n})(['MCMXC', 'MDCLXVI', 'MMVIII']);","[1990, 1666, 2008]","(function(lstTest) {\n    function romanValue(s) {\n        return s.length ? function() {\n            var parse = [].concat.apply([], glyphs.map(function(g) {\n                return 0 === s.indexOf(g) ? [trans[g], s.substr(g.length)] : [];\n            }));\n            return parse[0] + romanValue(parse[1]);\n        }() : 0;\n    }\n    var trans = {\n            M: 1E3,\n            CM: 900,\n            D: 500,\n            CD: 400,\n            C: 100,\n            XC: 90,\n            L: 50,\n            XL: 40,\n            X: 10,\n            IX: 9,\n            V: 5,\n            IV: 4,\n            I: 1\n        },\n        glyphs = Object.keys(trans);\n    return lstTest.map(romanValue);\n})([\"MCMXC\", \"MDCLXVI\", \"MMVIII\", \"MMMM\"]);","[1990, 1666, 2008]"],"uncertainCodeArray":[],"textArray":[]}