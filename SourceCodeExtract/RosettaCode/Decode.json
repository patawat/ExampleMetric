{"isSuccess":true,"url":"http://rosettacode.org//wiki/Roman_numerals/Decode","codeArray":["var Roman = {\n    Values: [['M', 1000], ['CM', 900], ['D',  500], ['CD', 400], \n             ['C',  100], ['XC',  90], ['L',  50],  ['XL',  40],  \n             ['X',   10], ['IX',   9], ['V',   5],  ['IV',   4],   \n             ['I',    1]],\n    parse: function(str) {\n      var result = 0\n      for (var i=0; i<Roman.Values.length; ++i) {\n        var pair = Roman.Values[i]\n        var key = pair[0]\n        var value = pair[1]\n        var regex = RegExp('^' + key)\n        while (str.match(regex)) {\n          result += value\n          str = str.replace(regex, '')\n        }\n      }\n      return result\n    }\n  }\n  var test_data = ['MCMXC', 'MDCLXVI', 'MMVIII']\n  for (var i=0; i<test_data.length; ++i) {\n    var test_datum = test_data[i]\n    print(test_datum + \": \" + Roman.parse(test_datum)) \n  }(function (lstTest) {\n      var mapping = [[\"M\", 1000], [\"CM\", 900], [\"D\", 500], [\"CD\", 400], [\"C\", 100], [\n          \"XC\", 90], [\"L\", 50], [\"XL\", 40], [\"X\", 10], [\"IX\", 9], [\"V\", 5], [\"IV\",\n          4], [\"I\", 1]];\n      // s -> n\n      function romanValue(s) {\n          // recursion over list of characters\n          // [c] -> n\n          function toArabic(lst) {\n              return lst.length ? function (xs) {\n                  var lstParse = chain(mapping, function (lstPair) {\n                      return isPrefixOf(\n                          lstPair[0], xs\n                      ) ? [lstPair[1], drop(lstPair[0].length, xs)] : []\n                  });\n                  return lstParse[0] + toArabic(lstParse[1]);\n              }(lst) : 0\n          }\n          return toArabic(s.split(''));\n      }\n      // Monadic bind (chain) for lists\n      function chain(xs, f) {\n          return [].concat.apply([], xs.map(f));\n      }\n      // [a] -> [a] -> Bool\n      function isPrefixOf(lstFirst, lstSecond) {\n          return lstFirst.length ? (\n              lstSecond.length ?\n              lstFirst[0] === lstSecond[0] && isPrefixOf(\n                  lstFirst.slice(1), lstSecond.slice(1)\n              ) : false\n          ) : true;\n      }\n      // Int -> [a] -> [a]\n      function drop(n, lst) {\n          return n <= 0 ? lst : (\n              lst.length ? drop(n - 1, lst.slice(1)) : []\n          );\n      }\n      return lstTest.map(romanValue);\n  })(['MCMXC', 'MDCLXVI', 'MMVIII']);[1990, 1666, 2008](function (lstTest) {\n      function romanValue(s) {\n          return s.length ? function () {\n              var parse = [].concat.apply([], glyphs.map(function (g) {\n                  return 0 === s.indexOf(g) ? [trans[g], s.substr(g.length)] : [];\n              }));\n              return parse[0] + romanValue(parse[1]);\n          }() : 0;\n      }\n      var trans = {\n              M: 1E3,\n              CM: 900,\n              D: 500,\n              CD: 400,\n              C: 100,\n              XC: 90,\n              L: 50,\n              XL: 40,\n              X: 10,\n              IX: 9,\n              V: 5,\n              IV: 4,\n              I: 1\n          },\n          glyphs = Object.keys(trans);\n      return lstTest.map(romanValue);\n  })([\"MCMXC\", \"MDCLXVI\", \"MMVIII\", \"MMMM\"]);[1990, 1666, 2008]"],"uncertainCodeArray":[],"textArray":[]}