{"isSuccess":true,"url":"http://rosettacode.org//wiki/Align_columns","codeArray":[" var justification = \"center\",\n     input = [\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n         \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n         \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n         \"column$are$separated$by$at$least$one$space.\",\n         \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n         \"justified,$right$justified,$or$center$justified$within$its$column.\"\n     ],\n     x, y, cols, max, cols = 0,\n     diff, left, right\n String.prototype.repeat = function(n) {\n     return new Array(1 + parseInt(n)).join(this);\n }\n for (x = 0; x < input.length; x++) {\n     input[x] = input[x].split(\"$\");\n     if (input[x].length > cols) cols = input[x].length;\n }\n for (x = 0; x < cols; x++) {\n     max = 0;\n     for (y = 0; y < input.length; y++)\n         if (input[y][x] && max < input[y][x].length) max = input[y][x].length;\n     for (y = 0; y < input.length; y++)\n         if (input[y][x]) {\n             diff = (max - input[y][x].length) / 2;\n             left = \" \".repeat(Math.floor(diff));\n             right = \" \".repeat(Math.ceil(diff));\n             if (justification == \"left\") {\n                 right += left;\n                 left = \"\"\n             }\n             if (justification == \"right\") {\n                 left += right;\n                 right = \"\"\n             }\n             input[y][x] = left + input[y][x] + right;\n         }\n }\n for (x = 0; x < input.length; x++) input[x] = input[x].join(\" \");\n input = input.join(\"\\n\");\n document.write(input);","//break up each string by '$'. The assumption is that the user wants the trailing $.\nvar data = [\n        \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n        \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n        \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n        \"column$are$separated$by$at$least$one$space.\",\n        \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n        \"justified,$right$justified,$or$center$justified$within$its$column.\"\n    ].map(function(str) {\n        return str.split('$');\n    })\n    //boilerplate: get longest array or string in array\nvar getLongest = function(arr) {\n    return arr.reduce(function(acc, item) {\n        return acc.length > item.length ? acc : item;\n    }, 0);\n};\n//boilerplate: this function would normally be in a library like underscore, lodash, or ramda\nvar zip = function(items, toInsert) {\n    toInsert = (toInsert === undefined) ? null : toInsert;\n    var longestItem = getLongest(items);\n    return longestItem.map(function(_unused, index) {\n        return items.map(function(item) {\n            return item[index] === undefined ? toInsert : item[index];\n        });\n    });\n};\n//here's the part that's not boilerplate\nvar makeColumns = function(formatting, data) {\n    var zipData = zip(data, '');\n    var makeSpaces = function(num) {\n        return new Array(num + 1).join(' ');\n    };\n    var formattedCols = zipData.map(function(column) {\n        var maxLen = getLongest(column).length; //find the maximum word length\n        if (formatting === 'left') {\n            return column.map(function(word) {\n                return word + makeSpaces(maxLen - word.length);\n            });\n        } else if (formatting === 'right') {\n            return column.map(function(word) {\n                return makeSpaces(maxLen - word.length) + word;\n            });\n        } else {\n            return column.map(function(word) {\n                var spaces = maxLen - word.length,\n                    first = ~~(spaces / 2),\n                    last = spaces - first;\n                return makeSpaces(first) + word + makeSpaces(last);\n            });\n        }\n    });\n    return zip(formattedCols).map(function(row) {\n        return row.join(' ');\n    }).join('\\n');\n};","(function(strText) {\n    'use strict';\n    // [[a]] -> [[a]]\n    function transpose(lst) {\n        return lst[0].map(function(_, iCol) {\n            return lst.map(function(row) {\n                return row[iCol];\n            })\n        });\n    }\n    // (a -> b -> c) -> [a] -> [b] -> [c]\n    function zipWith(f, xs, ys) {\n        return xs.length === ys.length ? (\n            xs.map(function(x, i) {\n                return f(x, ys[i]);\n            })\n        ) : undefined;\n    }\n    // (a -> a -> Ordering) -> [a] -> a \n    function maximumBy(f, xs) {\n        return xs.reduce(function(a, x) {\n            return a === undefined ? x : (\n                f(x) > f(a) ? x : a\n            );\n        }, undefined)\n    }\n    // [String] -> String\n    function widest(lst) {\n        return maximumBy(length, lst)\n            .length;\n    }\n    // [[a]] -> [[a]]\n    function fullRow(lst, n) {\n        return lst.concat(Array.apply(null, Array(n - lst.length))\n            .map(function() {\n                return ''\n            }));\n    }\n    // String -> Int -> String\n    function nreps(s, n) {\n        var o = '';\n        if (n < 1) return o;\n        while (n > 1) {\n            if (n & 1) o += s;\n            n >>= 1;\n            s += s;\n        }\n        return o + s;\n    }\n    // [String] -> String\n    function unwords(xs) {\n        return xs.join('  ');\n    }\n    // [String] -> String\n    function unlines(xs) {\n        return xs.join('\\n');\n    }\n    // [a] -> Int\n    function length(xs) {\n        return xs.length;\n    }\n    // -- Int -> [String] -> [[String]]\n    function padWords(n, lstWords, eAlign) {\n        return lstWords.map(function(w) {\n            var lngPad = n - w.length;\n            return (\n                    (eAlign === eCenter) ? (function() {\n                        var lngHalf = Math.floor(lngPad / 2);\n                        return [\n                            nreps(' ', lngHalf), w,\n                            nreps(' ', lngPad - lngHalf)\n                        ];\n                    })() : (eAlign === eLeft) ? ['', w, nreps(' ', lngPad)] : [nreps(' ', lngPad), w, '']\n                )\n                .join('');\n        });\n    }\n    // MAIN\n    var eLeft = -1,\n        eCenter = 0,\n        eRight = 1;\n    var lstRows = strText.split('\\n')\n        .map(function(x) {\n            return x.split('$');\n        }),\n        lngCols = widest(lstRows),\n        lstCols = transpose(lstRows.map(function(r) {\n            return fullRow(r, lngCols)\n        })),\n        lstColWidths = lstCols.map(widest);\n    // THREE PARAGRAPHS, WITH VARIOUS WORD COLUMN ALIGNMENTS:\n    return [eLeft, eRight, eCenter]\n        .map(function(eAlign) {\n            var fPad = function(n, lstWords) {\n                return padWords(n, lstWords, eAlign);\n            };\n            return transpose(\n                    zipWith(fPad, lstColWidths, lstCols)\n                )\n                .map(unwords);\n        })\n        .map(unlines)\n        .join('\\n\\n');\n})(\n    \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\\n\\\n  are$delineated$by$a$single$'dollar'$character,$write$a$program\\n\\\n  that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\\n\\\n  column$are$separated$by$at$least$one$space.\\n\\\n  Further,$allow$for$each$word$in$a$column$to$be$either$left$\\n\\\n  justified,$right$justified,$or$center$justified$within$its$column.\"\n);"],"uncertainCodeArray":[],"textArray":[]}