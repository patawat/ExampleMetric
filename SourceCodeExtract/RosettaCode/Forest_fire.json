{"isSuccess":true,"url":"http://rosettacode.org//wiki/Forest_fire","codeArray":["\"use strict\"\nconst _ = require('lodash');\nconst WIDTH_ARGUMENT_POSITION = 2;\nconst HEIGHT_ARGUMENT_POSITION = 3;\nconst TREE_PROBABILITY = 0.5;\nconst NEW_TREE_PROBABILITY = 0.01;\nconst BURN_PROBABILITY = 0.0001;\nconst CONSOLE_RED = '\\x1b[31m';\nconst CONSOLE_GREEN = '\\x1b[32m';\nconst CONSOLE_COLOR_CLOSE = '\\x1b[91m';\nconst CONSOLE_CLEAR = '\\u001B[2J\\u001B[0;0f';\nconst NEIGHBOURS = [\n    [-1, -1],\n    [-1, 0],\n    [-1, 1],\n    [0, -1],\n    [0, 1],\n    [1, -1],\n    [1, 0],\n    [1, 1]\n];\nconst PRINT_DECODE = {\n    ' ': ' ',\n    'T': `${CONSOLE_GREEN}T${CONSOLE_COLOR_CLOSE}`,\n    'B': `${CONSOLE_RED}T${CONSOLE_COLOR_CLOSE}`,\n};\nconst CONDITIONS = {\n    'T': (forest, y, x) => Math.random() < BURN_PROBABILITY || burningNeighbour(forest, y, x) ? 'B' : 'T',\n    ' ': () => Math.random() < NEW_TREE_PROBABILITY ? 'T' : ' ',\n    'B': () => ' '\n};\nconst WIDTH = process.argv[WIDTH_ARGUMENT_POSITION] || 20;\nconst HEIGHT = process.argv[HEIGHT_ARGUMENT_POSITION] || 10;\nconst update = forest => {\n    return _.map(forest, (c, ci) => {\n        return _.map(c, (r, ri) => {\n            return CONDITIONS[r](forest, ci, ri);\n        });\n    });\n}\nconst printForest = forest => {\n    process.stdout.write(CONSOLE_CLEAR);\n    _.each(forest, c => {\n        _.each(c, r => {\n            process.stdout.write(PRINT_DECODE[r]);\n        });\n        process.stdout.write('\\n');\n    })\n}\nconst burningNeighbour = (forest, y, x) => {\n    return _(NEIGHBOURS)\n        .map(n => _.isUndefined(forest[y + n[0]]) ? null : forest[y + n[0]][x + n[1]])\n        .any(_.partial(_.isEqual, 'B'));\n};\nlet forest = _.times(HEIGHT, () => _.times(WIDTH, () => Math.random() < TREE_PROBABILITY ? 'T' : ' '));\nsetInterval(() => {\n    forest = update(forest);\n    printForest(forest)\n}, 20);","var forest = {\n    X: 50,\n    Y: 50,\n    propTree: 0.5,\n    propTree2: 0.01,\n    propBurn: 0.0001,\n    t: [],\n    c: ['rgb(255,255,255)', 'rgb(0,255,0)', 'rgb(255,0,0)']\n};\nfor (var i = 0; i < forest.Y; i++) {\n    forest.t[i] = [];\n    for (var j = 0; j < forest.Y; j++) {\n        forest.t[i][j] = Math.random() < forest.propTree ? 1 : 0;\n    }\n}\n\nfunction afterLoad(forest) {\n    var canvas = document.getElementById('canvas');\n    var c = canvas.getContext('2d');\n    for (var i = 0; i < forest.X; i++) {\n        for (var j = 0; j < forest.Y; j++) {\n            c.fillStyle = forest.c[forest.t[i][j]];\n            c.fillRect(10 * j, 10 * i, 10 * j + 9, 10 * i + 9);\n        }\n    }\n}\n\nfunction doStep(forest) {\n    var to = [];\n    for (var i = 0; i < forest.Y; i++) {\n        to[i] = forest.t[i].slice(0);\n    }\n    //indices outside the array are undefined; which converts to 0=empty on forced typecast\n    for (var i = 0; i < forest.Y; i++) {\n        for (var j = 0; j < forest.Y; j++) {\n            if (0 == to[i][j]) {\n                forest.t[i][j] = Math.random() < forest.propTree2 ? 1 : 0;\n            } else if (1 == to[i][j]) {\n                if (\n                    ((i > 0) && (2 == to[i - 1][j])) ||\n                    ((i < forest.Y - 1) && (2 == to[i + 1][j])) ||\n                    ((j > 0) && (2 == to[i][j - 1])) ||\n                    ((j < forest.X - 1) && (2 == to[i][j + 1]))\n                ) {\n                    forest.t[i][j] = 2;\n                } else {\n                    forest.t[i][j] = Math.random() < forest.propBurn ? 2 : 1;\n                }\n            } else if (2 == to[i][j]) {\n                //If it burns, it gets empty ...\n                forest.t[i][j] = 0;\n            }\n        }\n    }\n}\nwindow.setInterval(function() {\n    doStep(forest);\n    afterLoad(forest);\n}, 100);"],"uncertainCodeArray":[],"textArray":[]}