{"isSuccess":true,"url":"http://rosettacode.org//wiki/Ordered_Partitions","codeArray":["(function () {\n    'use strict';\n    // [n] -> [[[n]]]\n    function partitions(a1, a2, a3) {\n      var n = a1 + a2 + a3;\n      return combos(range(1, n), n, [a1, a2, a3]);\n    }\n    function combos(s, n, xxs) {\n      if (!xxs.length) return [[]];\n      var x = xxs[0],\n          xs = xxs.slice(1);\n      return mb( choose(s, n, x),                 function (l_rest) {\n      return mb( combos(l_rest[1], (n - x), xs),  function (r) {\n        // monadic return/injection requires 1 additional\n        // layer of list nesting:\n        return [ [l_rest[0]].concat(r) ];\n      })});\n    }\n    function choose(aa, n, m) {\n      if (!m) return [[[], aa]];\n      var a = aa[0],\n          as = aa.slice(1);\n      return n === m ? (\n        [[aa, []]]\n      ) : (\n        choose(as, n - 1, m - 1).map(function (xy) {\n          return [[a].concat(xy[0]), xy[1]];\n        }).concat(choose(as, n - 1, m).map(function (xy) {\n          return [xy[0], [a].concat(xy[1])];\n        }))\n      );\n    }\n    // GENERIC\n    // Monadic bind (chain) for lists\n    function mb(xs, f) {\n      return [].concat.apply([], xs.map(f));\n    }\n    // [m..n]\n    function range(m, n) {\n      return Array.apply(null, Array(n - m + 1)).map(function (x, i) {\n        return m + i;\n      });\n    }\n    // EXAMPLE\n    return partitions(2, 0, 2);\n  })();[[[1, 2], [], [3, 4]], \n   [[1, 3], [], [2, 4]],\n   [[1, 4], [], [2, 3]],\n   [[2, 3], [], [1, 4]],\n   [[2, 4], [], [1, 3]],\n   [[3, 4], [], [1, 2]]]"],"uncertainCodeArray":[],"textArray":[]}