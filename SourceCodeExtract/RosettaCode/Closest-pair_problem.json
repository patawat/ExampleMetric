{"isSuccess":true,"url":"http://rosettacode.org//wiki/Closest-pair_problem","codeArray":["function distance(p1, p2) {\n    var dx = Math.abs(p1.x - p2.x);\n    var dy = Math.abs(p1.y - p2.y);\n    return Math.sqrt(dx*dx + dy*dy);\n  }\n  function bruteforceClosestPair(arr) {\n    if (arr.length < 2) {\n      return Infinity;\n    } else {\n      var minDist = distance(arr[0], arr[1]);\n      var minPoints = arr.slice(0, 2);\n      for (var i=0; i<arr.length-1; i++) {\n        for (var j=i+1; j<arr.length; j++) {\n          if (distance(arr[i], arr[j]) < minDist) {\n            minDist = distance(arr[i], arr[j]);\n            minPoints = [ arr[i], arr[j] ];\n          }\n        }\n      }\n      return {\n        distance: minDist,\n        points: minPoints\n      };\n    }\n  }Â \n  var Point = function(x, y) {\n  \tthis.x = x;\n  \tthis.y = y;\n  };\n  Point.prototype.getX = function() {\n  \treturn this.x;\n  };\n  Point.prototype.getY = function() {\n  \treturn this.y;\n  };\n  var mergeSort = function mergeSort(points, comp) {\n  \tif(points.length < 2) return points;\n  \tvar n = points.length,\n  \t\ti = 0,\n  \t\tj = 0,\n  \t\tleftN = Math.floor(n / 2),\n  \t\trightN = leftN;\n  \tvar leftPart = mergeSort( points.slice(0, leftN), comp),\n  \t\trightPart = mergeSort( points.slice(rightN), comp );\n  \tvar sortedPart = [];\n  \twhile((i < leftPart.length) && (j < rightPart.length)) {\n  \t\tif(comp(leftPart[i], rightPart[j]) < 0) {\n  \t\t\tsortedPart.push(leftPart[i]);\n  \t\t\ti += 1;\n  \t\t}\n  \t\telse {\n  \t\t\tsortedPart.push(rightPart[j]);\n  \t\t\tj += 1;\n  \t\t}\n  \t}\n  \twhile(i < leftPart.length) {\n  \t\tsortedPart.push(leftPart[i]);\n  \t\ti += 1;\n  \t}\n  \twhile(j < rightPart.length) {\n  \t\tsortedPart.push(rightPart[j]);\n  \t\tj += 1;\n  \t}\n  \treturn sortedPart;\n  };\n  var closestPair = function _closestPair(Px, Py) {\n  \tif(Px.length < 2) return { distance: Infinity, pair: [ new Point(0, 0), new Point(0, 0) ] };\n  \tif(Px.length < 3) {\n  \t\t//find euclid distance\n  \t\tvar d = Math.sqrt( Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2) );\n  \t\treturn {\n  \t\t\tdistance: d,\n  \t\t\tpair: [ Px[0], Px[1] ]\n  \t\t};\n  \t}\n  \tvar\tn = Px.length,\n  \t\tleftN = Math.floor(n / 2),\n  \t\trightN = leftN;\n  \tvar Xl = Px.slice(0, leftN),\n  \t\tXr = Px.slice(rightN),\n  \t\tXm = Xl[leftN - 1],\n  \t\tYl = [],\n  \t\tYr = [];\n  \t//separate Py\n  \tfor(var i = 0; i < Py.length; i += 1) {\n  \t\tif(Py[i].x <= Xm.x)\n  \t\t\tYl.push(Py[i]);\n  \t\telse\n  \t\t\tYr.push(Py[i]);\n  \t}\n  \tvar dLeft = _closestPair(Xl, Yl),\n  \t\tdRight = _closestPair(Xr, Yr);\n  \tvar minDelta = dLeft.distance,\n  \t\tclosestPair = dLeft.pair;\n  \tif(dLeft.distance > dRight.distance) {\n  \t\tminDelta = dRight.distance;\n  \t\tclosestPair = dRight.pair;\n  \t}\n  \t//filter points around Xm within delta (minDelta)\n  \tvar closeY = [];\n  \tfor(i = 0; i < Py.length; i += 1) {\n  \t\tif(Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);\n  \t}\n  \t//find min within delta. 8 steps max\n  \tfor(i = 0; i < closeY.length; i += 1) {\n  \t\tfor(var j = i + 1; j < Math.min( (i + 8), closeY.length ); j += 1) {\n  \t\t\tvar d = Math.sqrt( Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2) );\n  \t\t\tif(d < minDelta) {\n  \t\t\t\tminDelta = d;\n  \t\t\t\tclosestPair = [ closeY[i], closeY[j] ]\n  \t\t\t}\n  \t\t}\n  \t}\n  \treturn {\n  \t\tdistance: minDelta,\n  \t\tpair: closestPair\n  \t};\n  };\n  var points = [\n  \tnew Point(0.748501, 4.09624),\n  \tnew Point(3.00302, 5.26164),\n  \tnew Point(3.61878,  9.52232),\n  \tnew Point(7.46911,  4.71611),\n  \tnew Point(5.7819,   2.69367),\n  \tnew Point(2.34709,  8.74782),\n  \tnew Point(2.87169,  5.97774),\n  \tnew Point(6.33101,  0.463131),\n  \tnew Point(7.46489,  4.6268),\n  \tnew Point(1.45428,  0.087596)\n  ];\n  var sortX = function (a, b) { return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0); }\n  var sortY = function (a, b) { return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0); }\n  var Px = mergeSort(points, sortX);\n  var Py = mergeSort(points, sortY);\n  console.log(JSON.stringify(closestPair(Px, Py))) // {\"distance\":0.0894096443343775,\"pair\":[{\"x\":7.46489,\"y\":4.6268},{\"x\":7.46911,\"y\":4.71611}]}\n  var points2 = [new Point(37100, 13118), new Point(37134, 1963), new Point(37181, 2008), new Point(37276, 21611), new Point(37307, 9320)];\n  Px = mergeSort(points2, sortX);\n  Py = mergeSort(points2, sortY);\n  console.log(JSON.stringify(closestPair(Px, Py))); // {\"distance\":65.06919393998976,\"pair\":[{\"x\":37134,\"y\":1963},{\"x\":37181,\"y\":2008}]}"],"uncertainCodeArray":[],"textArray":[]}