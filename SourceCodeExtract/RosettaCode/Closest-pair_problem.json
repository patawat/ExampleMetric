{"isSuccess":true,"url":"http://rosettacode.org//wiki/Closest-pair_problem","codeArray":["function distance(p1, p2) {\n    var dx = Math.abs(p1.x - p2.x);\n    var dy = Math.abs(p1.y - p2.y);\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction bruteforceClosestPair(arr) {\n    if (arr.length < 2) {\n        return Infinity;\n    } else {\n        var minDist = distance(arr[0], arr[1]);\n        var minPoints = arr.slice(0, 2);\n        for (var i = 0; i < arr.length - 1; i++) {\n            for (var j = i + 1; j < arr.length; j++) {\n                if (distance(arr[i], arr[j]) < minDist) {\n                    minDist = distance(arr[i], arr[j]);\n                    minPoints = [arr[i], arr[j]];\n                }\n            }\n        }\n        return {\n            distance: minDist,\n            points: minPoints\n        };\n    }\n}"," var Point = function(x, y) {\n     this.x = x;\n     this.y = y;\n };\n Point.prototype.getX = function() {\n     return this.x;\n };\n Point.prototype.getY = function() {\n     return this.y;\n };\n var mergeSort = function mergeSort(points, comp) {\n     if (points.length < 2) return points;\n     var n = points.length,\n         i = 0,\n         j = 0,\n         leftN = Math.floor(n / 2),\n         rightN = leftN;\n     var leftPart = mergeSort(points.slice(0, leftN), comp),\n         rightPart = mergeSort(points.slice(rightN), comp);\n     var sortedPart = [];\n     while ((i < leftPart.length) && (j < rightPart.length)) {\n         if (comp(leftPart[i], rightPart[j]) < 0) {\n             sortedPart.push(leftPart[i]);\n             i += 1;\n         } else {\n             sortedPart.push(rightPart[j]);\n             j += 1;\n         }\n     }\n     while (i < leftPart.length) {\n         sortedPart.push(leftPart[i]);\n         i += 1;\n     }\n     while (j < rightPart.length) {\n         sortedPart.push(rightPart[j]);\n         j += 1;\n     }\n     return sortedPart;\n };\n var closestPair = function _closestPair(Px, Py) {\n     if (Px.length < 2) return {\n         distance: Infinity,\n         pair: [new Point(0, 0), new Point(0, 0)]\n     };\n     if (Px.length < 3) {\n         //find euclid distance\n         var d = Math.sqrt(Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2));\n         return {\n             distance: d,\n             pair: [Px[0], Px[1]]\n         };\n     }\n     var n = Px.length,\n         leftN = Math.floor(n / 2),\n         rightN = leftN;\n     var Xl = Px.slice(0, leftN),\n         Xr = Px.slice(rightN),\n         Xm = Xl[leftN - 1],\n         Yl = [],\n         Yr = [];\n     //separate Py\n     for (var i = 0; i < Py.length; i += 1) {\n         if (Py[i].x <= Xm.x)\n             Yl.push(Py[i]);\n         else\n             Yr.push(Py[i]);\n     }\n     var dLeft = _closestPair(Xl, Yl),\n         dRight = _closestPair(Xr, Yr);\n     var minDelta = dLeft.distance,\n         closestPair = dLeft.pair;\n     if (dLeft.distance > dRight.distance) {\n         minDelta = dRight.distance;\n         closestPair = dRight.pair;\n     }\n     //filter points around Xm within delta (minDelta)\n     var closeY = [];\n     for (i = 0; i < Py.length; i += 1) {\n         if (Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);\n     }\n     //find min within delta. 8 steps max\n     for (i = 0; i < closeY.length; i += 1) {\n         for (var j = i + 1; j < Math.min((i + 8), closeY.length); j += 1) {\n             var d = Math.sqrt(Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2));\n             if (d < minDelta) {\n                 minDelta = d;\n                 closestPair = [closeY[i], closeY[j]]\n             }\n         }\n     }\n     return {\n         distance: minDelta,\n         pair: closestPair\n     };\n };\n var points = [\n     new Point(0.748501, 4.09624),\n     new Point(3.00302, 5.26164),\n     new Point(3.61878, 9.52232),\n     new Point(7.46911, 4.71611),\n     new Point(5.7819, 2.69367),\n     new Point(2.34709, 8.74782),\n     new Point(2.87169, 5.97774),\n     new Point(6.33101, 0.463131),\n     new Point(7.46489, 4.6268),\n     new Point(1.45428, 0.087596)\n ];\n var sortX = function(a, b) {\n     return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0);\n }\n var sortY = function(a, b) {\n     return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0);\n }\n var Px = mergeSort(points, sortX);\n var Py = mergeSort(points, sortY);\n console.log(JSON.stringify(closestPair(Px, Py))) // {\"distance\":0.0894096443343775,\"pair\":[{\"x\":7.46489,\"y\":4.6268},{\"x\":7.46911,\"y\":4.71611}]}\n var points2 = [new Point(37100, 13118), new Point(37134, 1963), new Point(37181, 2008), new Point(37276, 21611), new Point(37307, 9320)];\n Px = mergeSort(points2, sortX);\n Py = mergeSort(points2, sortY);\n console.log(JSON.stringify(closestPair(Px, Py))); // {\"distance\":65.06919393998976,\"pair\":[{\"x\":37134,\"y\":1963},{\"x\":37181,\"y\":2008}]}"],"uncertainCodeArray":[],"textArray":[]}