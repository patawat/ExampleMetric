{"isSuccess":true,"url":"http://rosettacode.org//wiki/Sieve_of_Eratosthenes","codeArray":["function eratosthenes(limit) {\n      var primes = [];\n      if (limit >= 2) {\n          var sqrtlmt = Math.sqrt(limit) - 2;\n          var nums = new Array(); // start with an empty Array...\n          for (var i = 2; i <= limit; i++) // and\n              nums.push(i); // only initialize the Array once...\n          for (var i = 0; i <= sqrtlmt; i++) {\n              var p = nums[i]\n              if (p)\n                  for (var j = p * p - 2; j < nums.length; j += p)\n                      nums[j] = 0;\n          }\n          for (var i = 0; i < nums.length; i++) {\n              var p = nums[i];\n              if (p)\n                  primes.push(p);\n          }\n      }\n      return primes;\n  }\n  var primes = eratosthenes(100);\n  if (typeof print == \"undefined\")\n      print = (typeof WScript != \"undefined\") ? WScript.Echo : alert;\n  print(primes);function eratosthenes(limit) {\n      var prms = [];\n      if (limit >= 2) prms = [2];\n      if (limit >= 3) {\n          var sqrtlmt = (Math.sqrt(limit) - 3) >> 1;\n          var lmt = (limit - 3) >> 1;\n          var bfsz = (lmt >> 5) + 1\n          var buf = [];\n          for (var i = 0; i < bfsz; i++)\n              buf.push(0);\n          for (var i = 0; i <= sqrtlmt; i++)\n              if ((buf[i >> 5] & (1 << (i & 31))) == 0) {\n                  var p = i + i + 3;\n                  for (var j = (p * p - 3) >> 1; j <= lmt; j += p)\n                      buf[j >> 5] |= 1 << (j & 31);\n              }\n          for (var i = 0; i <= lmt; i++)\n              if ((buf[i >> 5] & (1 << (i & 31))) == 0)\n                  prms.push(i + i + 3);\n      }\n      return prms;\n  }var SoEIncClass = (function () {\n      function SoEIncClass() {\n          this.n = 0;\n      }\n      SoEIncClass.prototype.next = function () {\n          this.n += 2;\n          if (this.n < 7) { // initialization of sequence to avoid runaway:\n              if (this.n < 3) { // only even of two:\n                  this.n = 1; // odds from here...\n                  return 2;\n              }\n              if (this.n < 5)\n                  return 3;\n              this.dict = {}; // n must be 5...\n              this.bps = new SoEIncClass(); // new source of base primes\n              this.bps.next(); // advance past the even prime of two...\n              this.p = this.bps.next(); // first odd prime (3 in this case)\n              this.q = this.p * this.p; // set guard\n              return 5;\n          } else { // past initialization:\n              var s = this.dict[this.n]; // may or may not be defined...\n              if (!s) { // not defined:\n                  if (this.n < this.q) // haven't reached the guard:\n                      return this.n; // found a prime\n                  else { // n === q => not prime but at guard, so:\n                      var p2 = this.p << 1; // the span odds-only is twice prime\n                      this.dict[this.n + p2] = p2; // add next composite of prime to dict\n                      this.p = this.bps.next();\n                      this.q = this.p * this.p; // get next base prime guard\n                      return this.next(); // not prime so advance...\n                  }\n              } else { // is a found composite of previous base prime => not prime\n                  delete this.dict[this.n]; // advance to next composite of this prime:\n                  var nxt = this.n + s;\n                  while (this.dict[nxt]) nxt += s; // find unique empty slot in dict\n                  this.dict[nxt] = s; // to put the next composite for this base prime\n                  return this.next(); // not prime so advance...\n              }\n          }\n      };\n      return SoEIncClass;\n  })();var gen = new SoEIncClass(); \n  for (var i = 1; i < 1000000; i++, gen.next());\n  var prime = gen.next();\n  if (typeof print == \"undefined\")\n      print = (typeof WScript != \"undefined\") ? WScript.Echo : alert;\n  print(prime);var SoEPgClass = (function () {\n      function SoEPgClass() {\n          this.bi = -1; // constructor resets the enumeration to start...\n      }\n      SoEPgClass.prototype.next = function () {\n          if (this.bi < 1) {\n              if (this.bi < 0) {\n                  this.bi++;\n                  this.lowi = 0; // other initialization done here...\n                  this.bpa = [];\n                  return 2;\n              } else { // bi must be zero:\n                  var nxt = 3 + (this.lowi << 1) + 262144;\n                  this.buf = new Array();\n                  for (var i = 0; i < 4096; i++) // faster initialization:\n                      this.buf.push(0);\n                  if (this.lowi <= 0) { // special culling for first page as no base primes yet:\n                      for (var i = 0, p = 3, sqr = 9; sqr < nxt; i++, p += 2, sqr = p * p)\n                          if ((this.buf[i >> 5] & (1 << (i & 31))) === 0)\n                              for (var j = (sqr - 3) >> 1; j < 131072; j += p)\n                                  this.buf[j >> 5] |= 1 << (j & 31);\n                  } else { // after the first page:\n                      if (!this.bpa.length) { // if this is the first page after the zero one:\n                          this.bps = new SoEPgClass(); // initialize separate base primes stream:\n                          this.bps.next(); // advance past the only even prime of two\n                          this.bpa.push(this.bps.next()); // get the next prime (3 in this case)\n                      }\n                      // get enough base primes for the page range...\n                      for (var p = this.bpa[this.bpa.length - 1], sqr = p * p; sqr < nxt;\n                              p = this.bps.next(), this.bpa.push(p), sqr = p * p) ;\n                      for (var i = 0; i < this.bpa.length; i++) {\n                          var p = this.bpa[i];\n                          var s = (p * p - 3) >> 1;\n                          if (s >= this.lowi) // adjust start index based on page lower limit...\n                              s -= this.lowi;\n                          else {\n                              var r = (this.lowi - s) % p;\n                              s = (r != 0) ? p - r : 0;\n                          }\n                          for (var j = s; j < 131072; j += p)\n                              this.buf[j >> 5] |= 1 << (j & 31);\n                      }\n                  }\n              }\n          }\n          while (this.bi < 131072 && this.buf[this.bi >> 5] & (1 << (this.bi & 31)))\n              this.bi++; // find next marker still with prime status\n          if (this.bi < 131072) // within buffer: output computed prime\n              return 3 + ((this.lowi + this.bi++) << 1);\n          else { // beyond buffer range: advance buffer\n              this.bi = 0;\n              this.lowi += 131072;\n              return this.next(); // and recursively loop\n          }\n      };\n      return SoEPgClass;\n  })();"],"uncertainCodeArray":[],"textArray":[]}