{"isSuccess":true,"url":"http://rosettacode.org//wiki/Brace_expansion","codeArray":["(function() {\n    'use strict'\n    // Index of any closing brace matching the opening brace at iPosn\n    // with the indices of any immediately-enclosed commas\n    function bracePair(tkns, iPosn, iNest, lstCommas) {\n        if (iPosn >= tkns.length || iPosn < 0) return null;\n        var t = tkns[iPosn],\n            n = (t === '{') ? iNest + 1 : (t === '}' ? iNest - 1 : iNest),\n            lst = (t === ',' && iNest === 1) ? lstCommas.concat(iPosn) : lstCommas;\n        return n ? bracePair(tkns, iPosn + 1, n, lst) : {\n            close: iPosn,\n            commas: lst\n        };\n    }\n    // Parse of a SYNTAGM subtree\n    function andTree(dctSofar, tkns) {\n        if (!tkns.length) return [dctSofar, []];\n        var dctParse = dctSofar ? dctSofar : {\n                fn: and,\n                args: []\n            },\n            head = tkns[0],\n            tail = head ? tkns.slice(1) : [],\n            dctBrace = head === '{' ? bracePair(\n                tkns, 0, 0, []\n            ) : null,\n            lstOR = dctBrace && dctBrace.close && dctBrace.commas.length ? (\n                splitAt(dctBrace.close + 1, tkns)\n            ) : null;\n        return andTree({\n            fn: and,\n            args: dctParse.args.concat(\n                lstOR ? orTree(dctParse, lstOR[0], dctBrace.commas) : head\n            )\n        }, lstOR ? lstOR[1] : tail);\n    }\n    // Parse of a PARADIGM subtree\n    function orTree(dctSofar, tkns, lstCommas) {\n        if (!tkns.length) return [dctSofar, []];\n        var iLast = lstCommas.length;\n        return {\n            fn: or,\n            args: splitsAt(\n                lstCommas, tkns\n            ).map(function(x, i) {\n                var ts = x.slice(1, i === iLast ? -1 : void 0);\n                return ts.length ? ts : [''];\n            }).map(function(ts) {\n                return ts.length > 1 ? andTree(null, ts)[0] : ts[0];\n            })\n        };\n    }\n    // List of unescaped braces and commas, and remaining strings\n    function tokens(str) {\n        // Filter function excludes empty splitting artefacts\n        var toS = function(x) {\n            return x.toString();\n        };\n        return str.split(/(\\\\\\\\)/).filter(toS).reduce(function(a, s) {\n            return a.concat(s.charAt(0) === '\\\\' ? s : s.split(\n                /(\\\\*[{,}])/\n            ).filter(toS));\n        }, []);\n    }\n    // PARSE TREE OPERATOR (1 of 2)\n    // Each possible head * each possible tail\n    function and(args) {\n        var lng = args.length,\n            head = lng ? args[0] : null,\n            lstHead = \"string\" === typeof head ? [head] : head;\n        return lng ? (\n            1 < lng ? lstHead.reduce(function(a, h) {\n                return a.concat(and(args.slice(1)).map(function(t) {\n                    return h + t;\n                }));\n            }, []) : lstHead\n        ) : [];\n    }\n    // PARSE TREE OPERATOR (2 of 2)\n    // Each option flattened\n    function or(args) {\n        return args.reduce(function(a, b) {\n            return a.concat(b);\n        }, []);\n    }\n    // One list split into two (first sublist length n)\n    function splitAt(n, lst) {\n        return n < lst.length + 1 ? [lst.slice(0, n), lst.slice(n)] : [lst, []];\n    }\n    // One list split into several (sublist lengths [n])\n    function splitsAt(lstN, lst) {\n        return lstN.reduceRight(function(a, x) {\n            return splitAt(x, a[0]).concat(a.slice(1));\n        }, [lst]);\n    }\n    // Value of the parse tree\n    function evaluated(e) {\n        return typeof e === 'string' ? e :\n            e.fn(e.args.map(evaluated));\n    }\n    // JSON prettyprint (for parse tree, token list etc)\n    function pp(e) {\n        return JSON.stringify(e, function(k, v) {\n            return typeof v === 'function' ? (\n                '[function ' + v.name + ']'\n            ) : v;\n        }, 2)\n    }\n    // MAIN\n    // s -> [s]\n    function expansions(s) {\n        // BRACE EXPRESSION PARSED\n        var dctParse = andTree(null, tokens(s))[0];\n        // ABSTRACT SYNTAX TREE LOGGED\n        console.log(pp(dctParse));\n        // AST EVALUATED TO LIST OF STRINGS\n        return evaluated(dctParse);\n    }\n    // Sample expressions, double-escaped for quotation in source code.\n    var lstTests = [\n        '~/{Downloads,Pictures}/*.{jpg,gif,png}',\n        'It{{em,alic}iz,erat}e{d,}, please.',\n        '{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!',\n        '{}} some }{,{\\\\\\\\{ edge, edge} \\\\,}{ cases, {here} \\\\\\\\\\\\\\\\\\\\}'\n    ];\n    // 1. Return each expression with an indented list of its expansions, while\n    // 2. logging each parse tree to the console.log() stream\n    return lstTests.map(function(s) {\n        return s + '\\n\\n' + expansions(s).map(function(x) {\n            return '   ' + x;\n        }).join('\\n');\n    }).join('\\n\\n');\n})();","{\n    \"fn\": \"[function and]\",\n    \"args\": [\n        \"It\", {\n            \"fn\": \"[function or]\",\n            \"args\": [{\n                    \"fn\": \"[function and]\",\n                    \"args\": [{\n                            \"fn\": \"[function or]\",\n                            \"args\": [\n                                \"em\",\n                                \"alic\"\n                            ]\n                        },\n                        \"iz\"\n                    ]\n                },\n                \"erat\"\n            ]\n        },\n        \"e\", {\n            \"fn\": \"[function or]\",\n            \"args\": [\n                \"d\",\n                \"\"\n            ]\n        },\n        \",\",\n        \" please.\"\n    ]\n}"],"uncertainCodeArray":[],"textArray":[]}