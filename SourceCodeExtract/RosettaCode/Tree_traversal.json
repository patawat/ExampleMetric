{"isSuccess":true,"url":"http://rosettacode.org//wiki/Tree_traversal","codeArray":["function BinaryTree(value, left, right) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n}\nBinaryTree.prototype.preorder = function(f) {\n    this.walk(f, ['this', 'left', 'right'])\n}\nBinaryTree.prototype.inorder = function(f) {\n    this.walk(f, ['left', 'this', 'right'])\n}\nBinaryTree.prototype.postorder = function(f) {\n    this.walk(f, ['left', 'right', 'this'])\n}\nBinaryTree.prototype.walk = function(func, order) {\n    for (var i in order)\n        switch (order[i]) {\n            case \"this\":\n                func(this.value);\n                break;\n            case \"left\":\n                if (this.left) this.left.walk(func, order);\n                break;\n            case \"right\":\n                if (this.right) this.right.walk(func, order);\n                break;\n        }\n}\nBinaryTree.prototype.levelorder = function(func) {\n        var queue = [this];\n        while (queue.length != 0) {\n            var node = queue.shift();\n            func(node.value);\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n    }\n    // convenience function for creating a binary tree\nfunction createBinaryTreeFromArray(ary) {\n    var left = null,\n        right = null;\n    if (ary[1]) left = createBinaryTreeFromArray(ary[1]);\n    if (ary[2]) right = createBinaryTreeFromArray(ary[2]);\n    return new BinaryTree(ary[0], left, right);\n}\nvar tree = createBinaryTreeFromArray([1, [2, [4, [7]],\n        [5]\n    ],\n    [3, [6, [8],\n        [9]\n    ]]\n]);\nprint(\"*** preorder ***\");\ntree.preorder(print);\nprint(\"*** inorder ***\");\ntree.inorder(print);\nprint(\"*** postorder ***\");\ntree.postorder(print);\nprint(\"*** levelorder ***\");\ntree.levelorder(print);","(function() {\n    function preorder(n) {\n        return [n[v]].concat(\n            n[l] ? preorder(n[l]) : []\n        ).concat(\n            n[r] ? preorder(n[r]) : []\n        );\n    }\n\n    function inorder(n) {\n        return (\n            n[l] ? inorder(n[l]) : []\n        ).concat(\n            n[v]\n        ).concat(\n            n[r] ? inorder(n[r]) : []\n        );\n    }\n\n    function postorder(n) {\n        return (\n            n[l] ? postorder(n[l]) : []\n        ).concat(\n            n[r] ? postorder(n[r]) : []\n        ).concat(\n            n[v]\n        );\n    }\n\n    function levelorder(n) {\n        return (function loop(x) {\n            return x.length ? (\n                x[0] ? (\n                    [x[0][v]].concat(\n                        loop(\n                            x.slice(1).concat(\n                                [x[0][l], x[0][r]]\n                            )\n                        )\n                    )\n                ) : loop(x.slice(1))\n            ) : [];\n        })([n]);\n    }\n    var v = 0,\n        l = 1,\n        r = 2,\n        tree = [1, [2, [4, [7]],\n                [5]\n            ],\n            [3, [6, [8],\n                [9]\n            ]]\n        ],\n        lstTest = [\n            [\"Traversal\", \"Nodes visited\"]\n        ].concat(\n            [preorder, inorder, postorder, levelorder].map(\n                function(f) {\n                    return [f.name, f(tree)];\n                }\n            )\n        );\n    // [[a]] -> bool -> s -> s\n    function wikiTable(lstRows, blnHeaderRow, strStyle) {\n        return '{| class=\"wikitable\" ' + (\n            strStyle ? 'style=\"' + strStyle + '\"' : ''\n        ) + lstRows.map(function(lstRow, iRow) {\n            var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');\n            return '\\n|-\\n' + strDelim + ' ' + lstRow.map(function(v) {\n                return typeof v === 'undefined' ? ' ' : v;\n            }).join(' ' + strDelim + strDelim + ' ');\n        }).join('') + '\\n|}';\n    }\n    return wikiTable(lstTest, true) + '\\n\\n' + JSON.stringify(lstTest);\n})();","[\n    [\"Traversal\", \"Nodes visited\"],\n    [\"preorder\", [1, 2, 4, 7, 5, 3, 6, 8, 9]],\n    [\"inorder\", [7, 4, 2, 5, 1, 8, 6, 9, 3]],\n    [\"postorder\", [7, 4, 5, 2, 8, 9, 6, 3, 1]],\n    [\"levelorder\", [1, 2, 3, 4, 5, 6, 7, 8, 9]]\n]","(function() {\n    'use strict';\n    // 'preorder' | 'inorder' | 'postorder' | 'level-order'\n    // traverse :: String -> Tree {value: a, nest: [Tree]} -> [a]\n    function traverse(strOrderName, dctTree) {\n        var strName = strOrderName.toLowerCase();\n        if (strName.startsWith('level')) {\n            // LEVEL-ORDER\n            return levelOrder([dctTree]);\n        } else if (strName.startsWith('in')) {\n            var lstNest = dctTree.nest;\n            if ((lstNest ? lstNest.length : 0) < 3) {\n                var left = lstNest[0] || [],\n                    right = lstNest[1] || [],\n                    lstLeft = left.nest ? (\n                        traverse(strName, left)\n                    ) : (left.value || []),\n                    lstRight = right.nest ? (\n                        traverse(strName, right)\n                    ) : (right.value || []);\n                return (lstLeft !== undefined && lstRight !== undefined) ?\n                    // IN-ORDER\n                    (lstLeft instanceof Array ? lstLeft : [lstLeft])\n                    .concat(dctTree.value)\n                    .concat(lstRight) : undefined;\n            } else { // in-order only defined here for binary trees\n                return undefined;\n            }\n        } else {\n            var lstTraversed = concatMap(function(x) {\n                return traverse(strName, x);\n            }, (dctTree.nest || []));\n            return (\n                strName.startsWith('pre') ? (\n                    // PRE-ORDER\n                    [dctTree.value].concat(lstTraversed)\n                ) : strName.startsWith('post') ? (\n                    // POST-ORDER\n                    lstTraversed.concat(dctTree.value)\n                ) : []\n            );\n        }\n    }\n    // levelOrder :: [Tree {value: a, nest: [Tree]}] -> [a]\n    function levelOrder(lstTree) {\n        var lngTree = lstTree.length,\n            head = lngTree ? lstTree[0] : undefined,\n            tail = lstTree.slice(1);\n        // Recursively take any value found in the head node\n        // of the remaining tail, deferring any child nodes\n        // of that head to the end of the tail\n        return lngTree ? (\n            head ? (\n                [head.value].concat(\n                    levelOrder(\n                        tail\n                        .concat(head.nest || [])\n                    )\n                )\n            ) : levelOrder(tail)\n        ) : [];\n    }\n    // concatMap :: (a -> [b]) -> [a] -> [b]\n    function concatMap(f, xs) {\n        return [].concat.apply([], xs.map(f));\n    }\n    var dctTree = {\n        value: 1,\n        nest: [{\n            value: 2,\n            nest: [{\n                value: 4,\n                nest: [{\n                    value: 7\n                }]\n            }, {\n                value: 5\n            }]\n        }, {\n            value: 3,\n            nest: [{\n                value: 6,\n                nest: [{\n                    value: 8\n                }, {\n                    value: 9\n                }]\n            }]\n        }]\n    };\n    return ['preorder', 'inorder', 'postorder', 'level-order']\n        .reduce(function(a, k) {\n            return (\n                a[k] = traverse(k, dctTree),\n                a\n            );\n        }, {});\n})();","{\n    \"preorder\": [1, 2, 4, 7, 5, 3, 6, 8, 9],\n    \"inorder\": [7, 4, 2, 5, 1, 8, 6, 9, 3],\n    \"postorder\": [7, 4, 5, 2, 8, 9, 6, 3, 1],\n    \"level-order\": [1, 2, 3, 4, 5, 6, 7, 8, 9]\n}"],"uncertainCodeArray":[],"textArray":[]}