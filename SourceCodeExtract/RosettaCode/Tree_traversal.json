{"isSuccess":true,"url":"http://rosettacode.org//wiki/Tree_traversal","codeArray":["function BinaryTree(value, left, right) {\n      this.value = value;\n      this.left = left;\n      this.right = right;\n  }\n  BinaryTree.prototype.preorder  = function(f) {this.walk(f,['this','left','right'])}\n  BinaryTree.prototype.inorder   = function(f) {this.walk(f,['left','this','right'])}\n  BinaryTree.prototype.postorder = function(f) {this.walk(f,['left','right','this'])}\n  BinaryTree.prototype.walk = function(func, order) {\n      for (var i in order) \n          switch (order[i]) {\n              case \"this\": func(this.value); break;\n              case \"left\": if (this.left) this.left.walk(func, order); break;\n              case \"right\": if (this.right) this.right.walk(func, order); break;\n          }\n  }\n  BinaryTree.prototype.levelorder = function(func) {\n      var queue = [this];\n      while (queue.length != 0) {\n          var node = queue.shift();\n          func(node.value);\n          if (node.left) queue.push(node.left);\n          if (node.right) queue.push(node.right);\n      }\n  }\n  // convenience function for creating a binary tree\n  function createBinaryTreeFromArray(ary) {\n      var left = null, right = null;\n      if (ary[1]) left = createBinaryTreeFromArray(ary[1]);\n      if (ary[2]) right = createBinaryTreeFromArray(ary[2]);\n      return new BinaryTree(ary[0], left, right);\n  }\n  var tree = createBinaryTreeFromArray([1, [2, [4, [7]], [5]], [3, [6, [8],[9]]]]);\n  print(\"*** preorder ***\");   tree.preorder(print); \n  print(\"*** inorder ***\");    tree.inorder(print); \n  print(\"*** postorder ***\");  tree.postorder(print);\n  print(\"*** levelorder ***\"); tree.levelorder(print);(function () {\n      function preorder(n) {\n          return [n[v]].concat(\n              n[l] ? preorder(n[l]) : []\n          ).concat(\n              n[r] ? preorder(n[r]) : []\n          );\n      }\n      function inorder(n) {\n          return (\n              n[l] ? inorder(n[l]) : []\n          ).concat(\n              n[v]\n          ).concat(\n              n[r] ? inorder(n[r]) : []\n          );\n      }\n      function postorder(n) {\n          return (\n              n[l] ? postorder(n[l]) : []\n          ).concat(\n              n[r] ? postorder(n[r]) : []\n          ).concat(\n              n[v]\n          );\n      }\n      function levelorder(n) {\n          return (function loop(x) {\n              return x.length ? (\n                  x[0] ? (\n                  [x[0][v]].concat(\n                          loop(\n                              x.slice(1).concat(\n                                  [x[0][l], x[0][r]]\n                              )\n                          )\n                      )\n                  ) : loop(x.slice(1))\n              ) : [];\n          })([n]);\n      }\n      var v = 0,\n          l = 1,\n          r = 2,\n          tree = [1,\n                  [2,\n                      [4,\n                          [7]\n                      ],\n                      [5]\n                  ],\n                  [3,\n                      [6,\n                          [8],\n                          [9]\n                      ]\n                  ]\n              ],\n          lstTest = [[\"Traversal\", \"Nodes visited\"]].concat(\n              [preorder, inorder, postorder, levelorder].map(\n                  function (f) {\n                      return [f.name, f(tree)];\n                  }\n              )\n          );\n      // [[a]] -> bool -> s -> s\n      function wikiTable(lstRows, blnHeaderRow, strStyle) {\n          return '{| class=\"wikitable\" ' + (\n              strStyle ? 'style=\"' + strStyle + '\"' : ''\n          ) + lstRows.map(function (lstRow, iRow) {\n              var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');\n              return '\\n|-\\n' + strDelim + ' ' + lstRow.map(function (v) {\n                  return typeof v === 'undefined' ? ' ' : v;\n              }).join(' ' + strDelim + strDelim + ' ');\n          }).join('') + '\\n|}';\n      }\n      return wikiTable(lstTest, true) + '\\n\\n' + JSON.stringify(lstTest);\n  })();[[\"Traversal\",\"Nodes visited\"],\n  [\"preorder\",[1,2,4,7,5,3,6,8,9]],[\"inorder\",[7,4,2,5,1,8,6,9,3]],\n  [\"postorder\",[7,4,5,2,8,9,6,3,1]],[\"levelorder\",[1,2,3,4,5,6,7,8,9]]](function () {\n      'use strict';\n      // 'preorder' | 'inorder' | 'postorder' | 'level-order'\n      // traverse :: String -> Tree {value: a, nest: [Tree]} -> [a]\n      function traverse(strOrderName, dctTree) {\n          var strName = strOrderName.toLowerCase();\n          if (strName.startsWith('level')) {\n              // LEVEL-ORDER\n              return levelOrder([dctTree]);\n          } else if (strName.startsWith('in')) {\n              var lstNest = dctTree.nest;\n              if ((lstNest ? lstNest.length : 0) < 3) {\n                  var left = lstNest[0] || [],\n                      right = lstNest[1] || [],\n                      lstLeft = left.nest ? (\n                          traverse(strName, left)\n                      ) : (left.value || []),\n                      lstRight = right.nest ? (\n                          traverse(strName, right)\n                      ) : (right.value || []);\n                  return (lstLeft !== undefined && lstRight !== undefined) ?\n                      // IN-ORDER\n                      (lstLeft instanceof Array ? lstLeft : [lstLeft])\n                      .concat(dctTree.value)\n                      .concat(lstRight) : undefined;\n              } else { // in-order only defined here for binary trees\n                  return undefined;\n              }\n          } else {\n              var lstTraversed = concatMap(function (x) {\n                  return traverse(strName, x);\n              }, (dctTree.nest || []));\n              return (\n                  strName.startsWith('pre') ? (\n                      // PRE-ORDER\n                      [dctTree.value].concat(lstTraversed)\n                  ) : strName.startsWith('post') ? (\n                      // POST-ORDER\n                      lstTraversed.concat(dctTree.value)\n                  ) : []\n              );\n          }\n      }\n      // levelOrder :: [Tree {value: a, nest: [Tree]}] -> [a]\n      function levelOrder(lstTree) {\n          var lngTree = lstTree.length,\n              head = lngTree ? lstTree[0] : undefined,\n              tail = lstTree.slice(1);\n          // Recursively take any value found in the head node\n          // of the remaining tail, deferring any child nodes\n          // of that head to the end of the tail\n          return lngTree ? (\n              head ? (\n                  [head.value].concat(\n                      levelOrder(\n                          tail\n                          .concat(head.nest || [])\n                      )\n                  )\n              ) : levelOrder(tail)\n          ) : [];\n      }\n      // concatMap :: (a -> [b]) -> [a] -> [b]\n      function concatMap(f, xs) {\n          return [].concat.apply([], xs.map(f));\n      }\n      var dctTree = {\n          value: 1,\n          nest: [{\n              value: 2,\n              nest: [{\n                  value: 4,\n                  nest: [{\n                      value: 7\n                  }]\n              }, {\n                  value: 5\n              }]\n          }, {\n              value: 3,\n              nest: [{\n                  value: 6,\n                  nest: [{\n                      value: 8\n                  }, {\n                      value: 9\n                  }]\n              }]\n          }]\n      };\n      return ['preorder', 'inorder', 'postorder', 'level-order']\n          .reduce(function (a, k) {\n              return (\n                  a[k] = traverse(k, dctTree),\n                  a\n              );\n          }, {});\n  })();{\"preorder\":[1, 2, 4, 7, 5, 3, 6, 8, 9], \n  \"inorder\":[7, 4, 2, 5, 1, 8, 6, 9, 3], \n  \"postorder\":[7, 4, 5, 2, 8, 9, 6, 3, 1], \n  \"level-order\":[1, 2, 3, 4, 5, 6, 7, 8, 9]}"],"uncertainCodeArray":[],"textArray":[]}