{"isSuccess":true,"url":"http://rosettacode.org//wiki/Long_multiplication","codeArray":["function mult(strNum1, strNum2) {\n    var a1 = strNum1.split(\"\").reverse();\n    var a2 = strNum2.toString().split(\"\").reverse();\n    var aResult = new Array;\n    for (var iterNum1 = 0; iterNum1 < a1.length; iterNum1++) {\n        for (var iterNum2 = 0; iterNum2 < a2.length; iterNum2++) {\n            var idxIter = iterNum1 + iterNum2; // Get the current array position.\n            aResult[idxIter] = a1[iterNum1] * a2[iterNum2] + (idxIter >= aResult.length ? 0 : aResult[idxIter]);\n            if (aResult[idxIter] > 9) { // Carrying\n                aResult[idxIter + 1] = Math.floor(aResult[idxIter] / 10) + (idxIter + 1 >= aResult.length ? 0 : aResult[idxIter + 1]);\n                aResult[idxIter] -= Math.floor(aResult[idxIter] / 10) * 10;\n            }\n        }\n    }\n    return aResult.reverse().join(\"\");\n}\nmult('18446744073709551616', '18446744073709551616')","(function() {\n    'use strict';\n    // Javascript lacks an unbounded integer type\n    // so this multiplication function takes and returns\n    // long integer strings rather than any kind of native integer\n    // longMult :: (String | Integer) -> (String | Integer) -> String\n    function longMult(num1, num2) {\n        return largeIntegerString(\n            digitProducts(digits(num1), digits(num2))\n        );\n    }\n    // digitProducts :: [Int] -> [Int] -> [Int]\n    function digitProducts(xs, ys) {\n        return multTable(xs, ys)\n            .map(function(zs, i) {\n                return Array.apply(null, Array(i))\n                    .map(function() {\n                        return 0;\n                    })\n                    .concat(zs);\n            })\n            .reduce(function(a, x) {\n                if (a) {\n                    var lng = a.length;\n                    return x.map(function(y, i) {\n                        return y + (i < lng ? a[i] : 0);\n                    })\n                } else return x;\n            })\n    }\n    // largeIntegerString :: [Int] -> String\n    function largeIntegerString(lstColumnValues) {\n        var dctProduct = lstColumnValues\n            .reduceRight(function(a, x) {\n                var intSum = x + a.carried,\n                    intDigit = intSum % 10;\n                return {\n                    digits: intDigit\n                        .toString() + a.digits,\n                    carried: (intSum - intDigit) / 10\n                };\n            }, {\n                digits: '',\n                carried: 0\n            });\n        return (dctProduct.carried > 0 ? (\n            dctProduct.carried.toString()\n        ) : '') + dctProduct.digits;\n    }\n    // multTables :: [Int] -> [Int] -> [[Int]]\n    function multTable(xs, ys) {\n        return ys.map(function(y) {\n            return xs.map(function(x) {\n                return x * y;\n            })\n        });\n    }\n    // digits :: (Integer | String) -> [Integer]\n    function digits(n) {\n        return (typeof n === 'string' ? n : n.toString())\n            .split('')\n            .map(function(x) {\n                return parseInt(x, 10);\n            });\n    }\n    // TEST showing that larged bounded integer inputs give only rounded results\n    // whereas integer string inputs allow for full precision on this scale (2^128)\n    return {\n        fromIntegerStrings: longMult(\n            '18446744073709551616',\n            '18446744073709551616'\n        ),\n        fromBoundedIntegers: longMult(\n            18446744073709551616,\n            18446744073709551616\n        )\n    };\n})();"],"uncertainCodeArray":[],"textArray":[]}